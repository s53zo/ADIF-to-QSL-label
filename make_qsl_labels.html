<!DOCTYPE html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PZCLRVBKKT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);} 
  gtag('js', new Date());
  gtag('config', 'G-PZCLRVBKKT');
</script>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#ffffff" />
<title>ADIF to QSL Labels helper</title>
<style>
/* ===== Light & Dark Themes ===== */
:root{
--bg:#f8fafc; /* page background */
--panel:#ffffff; /* primary surface */
--panel-2:#f1f5f9; /* secondary surface */
--ink:#0f172a; /* text */
--muted:#64748b; /* secondary text */
--accent:#2563eb; /* brand */
--accent-2:#38bdf8; /* secondary brand */
--border:#e2e8f0; /* borders */
--ring:#3b82f6; /* focus ring */
--warn:#d97706; /* warning */
--good:#16a34a; /* success */
--shadow:0 4px 12px rgba(0,0,0,.08);
--radius:12px;
}
@media (prefers-color-scheme: dark){
:root{ --bg:#0f172a; --panel:#1e293b; --panel-2:#111827; --ink:#f8fafc; --muted:#94a3b8; --border:#334155; --shadow:0 8px 24px rgba(0,0,0,.4) }
}

body{margin:0; font-family:Inter, ui-sans-serif, system-ui, -apple-system, Roboto, Helvetica, Arial; background:var(--bg); color:var(--ink)}
body.card-mode .mode-labels-only{display:none !important}
body:not(.card-mode) .mode-card-only{display:none !important}
.app{display:grid; grid-template-columns: 380px 1fr; min-height:100vh}
aside{border-right:1px solid var(--border); background:var(--panel); padding:18px 20px; overflow:auto}
main{display:flex; flex-direction:column; height:100vh; position:sticky; top:0; align-self:start}

.mode-toggle{display:inline-flex; gap:12px; background:var(--panel-2); border-radius:999px; padding:6px; border:1px solid var(--border); box-shadow:var(--shadow)}
.mode-option{flex:1; border:none; background:transparent; color:var(--muted); padding:10px 18px; border-radius:999px; font-size:14px; font-weight:600; cursor:pointer; transition:all .2s}
.mode-option.selected{background:var(--accent); color:#fff; box-shadow:0 2px 6px rgba(37,99,235,0.25)}
.mode-option:not(.selected):hover{color:var(--ink); background:rgba(148,163,184,0.15)}

header{position:sticky; top:0; z-index:5; display:flex; gap:10px; padding:12px 16px; border-bottom:1px solid var(--border); align-items:center; background:var(--panel-2); box-shadow:var(--shadow)}
header h1{font-size:16px; font-weight:700; margin:0; color:var(--ink)}
header .spacer{flex:1}

.grid{display:grid; gap:14px}
.section{border:1px solid var(--border); border-radius:var(--radius); padding:14px; background:var(--panel); box-shadow:var(--shadow)}
.section h3{margin:0 0 10px 0; font-size:13px; color:var(--muted); text-transform:uppercase}

.section.collapsible{padding:0; overflow:hidden}
.collapsible > .section-toggle{width:100%; border:none; background:var(--panel); color:var(--ink); display:flex; align-items:center; gap:12px; padding:16px 18px; cursor:pointer; font-size:14px; font-weight:600; text-align:left; transition:background .2s ease, color .2s ease}
.collapsible > .section-toggle:focus-visible{outline:none; box-shadow:0 0 0 3px rgba(59,130,246,.3)}
.collapsible > .section-toggle:hover{background:var(--panel-2)}
.collapsible .section-icon{display:inline-flex; align-items:center; justify-content:center; width:24px; height:24px; border-radius:50%; background:rgba(59,130,246,0.15); color:var(--accent)}
.collapsible .section-icon svg{width:14px; height:14px}
.collapsible .section-title{flex:1; letter-spacing:0.02em}
.collapsible .section-chevron{display:inline-flex; transition:transform .2s ease; color:var(--muted)}
.collapsible .section-chevron svg{width:14px; height:14px}
.collapsible > .section-body{padding:16px 18px 18px 18px; border-top:1px solid var(--border); background:var(--panel)}
.collapsible > .section-body.collapsed{display:none}
.collapsible.is-collapsed > .section-toggle .section-chevron{transform:rotate(-90deg)}
.collapsible:not(.is-collapsed) > .section-toggle .section-chevron{transform:rotate(0deg)}
.section-hint{margin:0 0 14px 0; font-size:12px; color:var(--muted)}
.subsection{border:1px solid var(--border); border-radius:10px; margin-top:12px; overflow:hidden; background:var(--panel-2)}
.subsection.collapsible > .section-toggle{background:var(--panel-2)}
.subsection.collapsible > .section-toggle:hover{background:var(--panel)}
.subsection.collapsible > .section-body{background:var(--panel-2)}
.subsection:first-of-type{margin-top:0}
.version{margin-top:0; text-align:left; font-size:12px; color:var(--muted)}

label{font-size:13px; color:var(--muted)}
input[type="text"], input[type="number"], input[type="date"], select, input[type="file"]{
width:100%; padding:9px 12px; border-radius:10px; border:1px solid var(--border); background:var(--panel-2); color:var(--ink);
}
input[type="text"]::placeholder{color:var(--muted)}
input:focus, select:focus{ outline:none; border-color:var(--ring); box-shadow:0 0 0 3px rgba(59,130,246,.3)}

button{border-radius:10px; padding:10px 14px; font-size:14px; border:1px solid var(--border); color:var(--ink); background:var(--panel-2); cursor:pointer; transition:all .2s}
button:hover{background:var(--accent); color:white; border-color:var(--accent)}
button.primary{background:var(--accent); color:white; border-color:var(--accent)}
button.primary:hover{background:#1d4ed8}
button.secondary{background:var(--panel-2); color:var(--ink); border-color:var(--border)}
button.secondary:hover{background:var(--accent-2); color:#fff; border-color:var(--accent-2)}
button:disabled{cursor:not-allowed; opacity:0.65}
.row.qsl-filter-row{display:flex; flex-direction:column; gap:12px}
.row.qsl-filter-row>label{font-weight:600; color:var(--ink)}
.qsl-rule-builder{border:1px solid var(--border); border-radius:14px; padding:14px; background:var(--panel-2); display:flex; flex-direction:column; gap:14px; box-shadow:var(--shadow)}
.qsl-rule-list{display:flex; flex-direction:column; gap:10px}
.qsl-rule-row{
  display:grid;
  grid-template-columns:minmax(60px,80px) 1fr;
  grid-template-areas:
    "join field"
    "operator operator"
    "value value"
    "remove remove";
  gap:10px 14px;
  align-items:stretch;
  padding:12px;
  border:1px solid var(--border);
  border-radius:12px;
  background:var(--panel);
  width:100%;
  box-sizing:border-box;
}
.qsl-rule-row select,.qsl-rule-row input{width:100%; min-width:0}
.qsl-rule-cell{display:flex; flex-direction:column; gap:4px; width:100%}
.qsl-rule-cell::before{
  content:attr(data-label);
  font-size:10px;
  letter-spacing:0.08em;
  text-transform:uppercase;
  color:var(--muted);
}
.qsl-rule-cell-join{grid-area:join; align-self:center}
.qsl-rule-cell-field{grid-area:field}
.qsl-rule-cell-operator{grid-area:operator}
.qsl-rule-cell-value{grid-area:value}
.qsl-rule-cell-remove{grid-area:remove; align-items:flex-end}
.qsl-rule-cell-remove::before{display:none}
.qsl-rule-row-first .qsl-rule-cell-join{display:none}
.qsl-rule-remove{border:none; background:transparent; color:var(--muted); font-size:20px; line-height:1; padding:4px 6px; border-radius:999px; cursor:pointer}
.qsl-rule-remove:hover{background:rgba(56,189,248,0.2); color:var(--ink)}
.qsl-rule-empty{font-size:12px; color:var(--muted); padding:10px; border:1px dashed var(--border); border-radius:10px; text-align:center}
.qsl-rule-actions{display:flex; justify-content:flex-end}
.tooltip{position:relative; display:block}
.tooltip::after{content:attr(data-tooltip); position:absolute; left:50%; bottom:calc(100% + 6px); transform:translate(-55%, 6px); background:var(--panel); border:1px solid var(--border); box-shadow:var(--shadow); color:var(--ink); padding:8px 10px; border-radius:8px; font-size:12px; line-height:1.3; white-space:normal; width:max-content; max-width:260px; opacity:0; pointer-events:none; transition:opacity .1s ease, transform .1s ease; z-index:10}
.tooltip::before{content:""; position:absolute; left:50%; bottom:calc(100% + 2px); transform:translate(-55%, 4px) rotate(45deg); width:10px; height:10px; background:var(--panel); border-left:1px solid var(--border); border-top:1px solid var(--border); box-shadow:var(--shadow); opacity:0; transition:opacity .1s ease, transform .1s ease; z-index:9; transform-origin:center}
.tooltip.is-active::after{opacity:1; transform:translate(-55%, 2px)}
.tooltip.is-active::before{opacity:1; transform:translate(-55%, 0) rotate(45deg)}
.download-buttons .tooltip{width:100%}
.sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

.tag{padding:2px 8px; border-radius:999px; background:var(--accent-2); color:#fff; font-size:11px; margin-left:8px}
.stats{font-size:12px; color:var(--muted); margin-left:12px}

canvas{background:#ffffff; border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow)}
.preview-wrap{padding:16px; overflow:auto; flex:1; background:var(--panel-2)}
.controls{display:flex; gap:10px; align-items:center}
.overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(15,23,42,0.65); z-index:200}
.overlay .dialog{min-width:280px; padding:18px; border-radius:var(--radius); box-shadow:var(--shadow)}
.overlay .row{display:flex; gap:12px; margin-bottom:12px}
.overlay .actions{display:flex; gap:10px; justify-content:flex-end; margin-top:10px}

.banner{margin:10px 16px 0 16px; padding:12px 14px; border-radius:10px; background:#e0f2fe; color:#0369a1; font-size:13px}
.warn{color:var(--warn); font-size:12px}
.good{color:var(--good); font-size:12px}

.footer-bar{margin-top:18px; padding:14px 16px; border-radius:12px; border:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; align-items:flex-start; gap:12px}
.footer-bar label{font-size:12px; color:var(--muted); margin-right:8px}
.footer-bar select{padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:var(--panel-2); color:var(--ink)}
.footer-bar select:focus{outline:none; box-shadow:0 0 0 3px rgba(37,100,190,0.25)}
.footer-bar .theme-switcher{display:flex; align-items:center; gap:10px; width:100%; justify-content:space-between}
.footer-bar .theme-switcher select{min-width:180px}
.footer-message{font-size:11px; color:var(--muted)}
.footer-message a{color:var(--accent); text-decoration:none}
.footer-message a:hover{text-decoration:underline}
.footer-thanks{font-size:10px; color:var(--muted)}

@media (max-width: 1200px){
.app{grid-template-columns:1fr}
aside{border-right:none; border-bottom:1px solid var(--border)}
main{position:static; height:auto}
.mode-toggle{width:100%; justify-content:space-between}
.mode-option{flex:1}
.footer-bar{flex-direction:column; align-items:flex-start}
.footer-bar .theme-switcher{width:100%; justify-content:space-between}
.footer-bar .theme-switcher select{flex:1}
}
/* === Surface bindings (theme-controlled) === */
body{ color-scheme: light }
header{ background: var(--panel); box-shadow: var(--shadow) }
.section{ background: var(--panel-2) }
input[type="text"], input[type="number"], input[type="date"], select, input[type="file"]{ background: var(--panel-2); color: var(--ink); border-color: var(--border) }
#previewControls{ background: var(--panel) }
.banner{ background: var(--panel-2); border-color: var(--border); color: var(--ink) }
.tag{ background: var(--accent); border:none; color:#fff }
.dialog{ background: var(--panel) }
.download-buttons{display:flex; flex-direction:column; gap:10px; margin-top:10px}
.download-buttons button{width:100%}
.help{font-size:10px}
#downloadSection .help{text-align:center}
</style>
</head>
<body>
<div class="app">
  <aside>
    <div class="grid">
      <div class="section collapsible" data-section="data" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 3h8l5 5v13H7z"></path>
              <path d="M15 3v5h5"></path>
            </svg>
          </span>
          <span class="section-title">Data</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Load your ADIF log or try the bundled sample entries. Need to tweak fields? Open the Columns section below.</p>
          <div class="row">
            <label>ADIF file</label>
            <input id="adifFile" type="file" accept=".adi,.adif,.txt" />
          </div>
          <div class="row">
            <label>Sort order</label>
            <select id="sortMode">
              <option value="CALL" selected>Callsign (A→Z)</option>
              <option value="PREFIX">DXCC prefix (A→Z)</option>
              <option value="DATE_ASC">Date (old → new)</option>
              <option value="DATE_DESC">Date (new → old)</option>
              <option value="FIFO">As in ADIF (FIFO)</option>
            </select>
          </div>
          <div id="adifWarning" class="warn">Sample data is shown. Upload your ADIF to replace it.</div>
        </div>
      </div>

      <div class="section collapsible" data-section="filters" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 4h16l-6 7v5l-4 2v-7z"></path>
            </svg>
          </span>
          <span class="section-title">Filters</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Narrow QSOs by date, band, mode, or QSL status before printing.</p>
          <div class="row2">
            <div>
              <label class="small muted">Date from</label>
              <input id="fDateFrom" type="date" />
            </div>
            <div>
              <label class="small muted">Date to</label>
              <input id="fDateTo" type="date" />
            </div>
          </div>
          <div class="row"><label>Bands (CSV)</label><input id="fBands" type="text" placeholder="e.g. 20M,40M"></div>
          <div class="row"><label>Modes (CSV)</label><input id="fModes" type="text" placeholder="e.g. CW,SSB,FT8"></div>
          <div class="row"><label>DXCC / Prefix / Callsign (CSV)</label><input id="fDxcc" type="text" placeholder="e.g. JA, DL, S53ZO"></div>
          <div class="row qsl-filter-row">
            <label>QSL status filters</label>
            <div class="qsl-rule-builder">
              <div id="qslRuleList" class="qsl-rule-list" role="list"></div>
              <div id="qslRuleEmpty" class="qsl-rule-empty">No QSL filters applied.</div>
              <div class="qsl-rule-actions">
                <button type="button" id="addQslRule" class="secondary">Add QSL rule</button>
              </div>
              <p class="help">Mix paper, LoTW, and eQSL statuses with AND/OR joins on each rule. Example: “QSL_RCVD is Y” AND “QSL_SENT is blank or N”.</p>
            </div>
          </div>
          <datalist id="qslStatusSuggestions">
            <option value="Y">
            <option value="N">
            <option value="R">
            <option value="Q">
            <option value="I">
            <option value="E">
            <option value="V">
          </datalist>
          <div class="row">
            <label>Duplicates</label>
            <select id="fDedupe">
              <option value="OFF" selected>Keep all</option>
              <option value="NEWEST">Keep newest</option>
              <option value="OLDEST">Keep oldest</option>
            </select>
          </div>
          <div class="row">
            <label>After export include</label>
            <select id="exportScope">
              <option value="ALL">all ADIF QSOs</option>
              <option value="FILTERED" selected>only filtered QSOs</option>
            </select>
          </div>
          <p class="help">Filters apply live to preview & PDF.</p>
        </div>
      </div>
      <div class="section collapsible" id="modeSection" data-section="mode" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="5" width="18" height="14" rx="2"></rect>
              <path d="M12 5v14"></path>
            </svg>
          </span>
          <span class="section-title">What do you want to print?</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Choose between multi-label sheets and individual QSL cards.</p>
          <div class="mode-toggle" role="radiogroup" aria-label="Output mode">
            <button id="modeLabels" data-mode="labels" class="mode-option selected">Label sheets</button>
            <button id="modeCard" data-mode="qslCard" class="mode-option">Direct QSL card</button>
          </div>
        </div>
      </div>

      <div class="section collapsible" id="pageSection" data-section="page" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="4" y="4" width="16" height="16" rx="2"></rect>
              <path d="M4 12h16"></path>
              <path d="M12 4v16"></path>
            </svg>
          </span>
          <span class="section-title">Page & Start Position</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Align the template with your sheet before printing multiples.</p>
          <div class="row mode-labels-only"><label>Page Size</label>
            <select id="pageSize">
              <option value="A4" selected>A4 (210×297mm)</option>
              <option value="LETTER">Letter (8.5×11")</option>
            </select>
          </div>
          <div class="row mode-labels-only"><label>Cols</label><input id="cols" type="number" value="3" min="1"></div>
          <div class="row mode-labels-only"><label>Rows</label><input id="rows" type="number" value="8" min="1"></div>
          <div class="row mode-labels-only"><label>Label height (mm)</label><input id="labelH" type="number" step="0.5" value="33.8"></div>
          <div class="row mode-labels-only"><label>Left margin (mm)</label><input id="marginL" type="number" step="0.5" value="3"></div>
          <div class="row mode-labels-only"><label>Right margin (mm)</label><input id="marginR" type="number" step="0.5" value="3"></div>
          <div class="row mode-labels-only"><label>Space between labels - horizontal (mm)</label><input id="colGap" type="number" step="0.25" value="0"></div>
          <div class="row mode-labels-only"><label>Space between labels - vertical (mm)</label><input id="rowGap" type="number" step="0.25" value="0"></div>
          <div class="row mode-labels-only"><label>Top margin (mm)</label><input id="marginT" type="number" step="0.5" value="5"></div>
          <div class="row2 mode-labels-only">
            <div>
              <label class="small muted">Start at row</label>
              <input id="startRow" type="number" min="1" value="1" />
            </div>
            <div>
              <label class="small muted">Start at column</label>
              <input id="startCol" type="number" min="1" value="1" />
            </div>
          </div>
        </div>
      </div>

      <div class="section collapsible" id="columnsSection" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="16" rx="2"></rect>
              <path d="M3 10h18"></path>
              <path d="M9 4v16"></path>
              <path d="M15 4v16"></path>
            </svg>
          </span>
          <span class="section-title">Columns</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Choose which ADIF fields appear on each label and add custom headers.</p>
          <div class="columns" id="columns">
            <div class="muted">Columns (header + source). Defaults match Avery 3664.</div>
          </div>
          <div class="controls">
            <button id="addCol">+ Add column</button>
            <button id="resetCols">Reset to 3664 defaults</button>
          </div>
          <div class="muted" style="margin-top:8px">Min widths &amp; Static widths (mm) match the number of columns:</div>
          <div class="row"><label>Min col widths (mm, CSV)</label><input id="minColMM" type="text" value="12,10,10,10,6"></div>
          <div class="row"><label>Static col widths (mm, CSV)</label><input id="staticColMM" type="text" value="20,12,12,18,8"></div>
        </div>
      </div>

      <div class="section collapsible mode-card-only" id="cardSection" data-section="card" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="7" width="18" height="10" rx="2"></rect>
              <path d="M7 10h10"></path>
            </svg>
          </span>
          <span class="section-title">QSL Card</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Dial in your card size and fine-tune the printable label area.</p>
          <div class="row"><label>Card width (mm)</label><input id="cardWidth" type="number" step="0.5" value="150"></div>
          <div class="row"><label>Card height (mm)</label><input id="cardHeight" type="number" step="0.5" value="100"></div>
          <div class="row"><label>Label width (mm)</label><input id="cardLabelWidth" type="number" step="0.5" value="60"></div>
          <div class="row"><label>Label height (mm)</label><input id="cardLabelHeight" type="number" step="0.5" value="30"></div>
          <div class="row"><label>Label X offset (mm)</label><input id="cardLabelX" type="number" step="0.5" value="60"></div>
          <div class="row"><label>Label Y offset (mm)</label><input id="cardLabelY" type="number" step="0.5" value="50"></div>
          <div class="row"><label>Label rotation (deg)</label><input id="cardLabelRotation" type="number" step="0.5" value="0"></div>
        </div>
      </div>

      <div class="section collapsible" id="advancedSection" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="false">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V22a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H2a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H8a1.65 1.65 0 0 0 1-1.51V2a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V8a1.65 1.65 0 0 0 1.51 1H22a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
          </span>
          <span class="section-title">Advanced controls</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body collapsed">
          <p class="section-hint">Need precise alignment or styling tweaks? Expand the tools below.</p>

          <div class="subsection collapsible" data-initial="collapsed">
            <button class="section-toggle" type="button" aria-expanded="false">
              <span class="section-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="3"></circle>
                  <path d="M12 2v3"></path>
                  <path d="M12 19v3"></path>
                  <path d="M20 12h-3"></path>
                  <path d="M7 12H4"></path>
                </svg>
              </span>
              <span class="section-title">Offsets</span>
              <span class="section-chevron" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 10l4 4 4-4"></path>
                </svg>
              </span>
            </button>
            <div class="section-body collapsed">
              <p class="section-hint">Nudge the label grid when your printer feeds a bit off.</p>
              <div class="row"><label>Global X (mm)</label><input id="xOffset" type="number" step="0.5" value="0"></div>
              <div class="row"><label>Global Y (mm)</label><input id="yOffset" type="number" step="0.5" value="5"></div>
              <div class="row"><label>Per-column offsets (mm, CSV)</label><input id="colOffsets" type="text" value="0,0,0"></div>
              <div class="row"><label>Per-row offsets (mm, CSV)</label><input id="rowOffsets" type="text" value="0,0,0,0,0,0,0,0"></div>
              <p class="help">CSV lists auto-resize when you change columns/rows.</p>
            </div>
          </div>

          <div class="subsection collapsible" data-initial="collapsed">
            <button class="section-toggle" type="button" aria-expanded="false">
              <span class="section-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="5" y="7" width="14" height="10" rx="2"></rect>
                  <path d="M9 11h6"></path>
                </svg>
              </span>
              <span class="section-title">Inside label</span>
              <span class="section-chevron" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 10l4 4 4-4"></path>
                </svg>
              </span>
            </button>
            <div class="section-body collapsed">
              <p class="section-hint">Control padding and footer text for each printed label.</p>
              <div class="row"><label>Padding X (mm)</label><input id="padX" type="number" step="0.5" value="2"></div>
              <div class="row"><label>Padding Y (mm)</label><input id="padY" type="number" step="0.5" value="2"></div>
              <div class="row"><label>"To Radio" text</label><input id="toRadioText" type="text" value="To Radio"></div>
              <div class="row"><label>Left footer text</label><input id="footerL" type="text" value="SY: Blondie, South Adriatic sea"></div>
              <div class="row"><label>Right footer text</label><input id="footerR" type="text" value="TNX & 73"></div>
              <div class="row"><label>Right footer shift (mm)</label><input id="footerRShift" type="number" step="0.5" value="5"></div>
              <div class="row"><label>Footer Y shift (mm)</label><input id="footerYShift" type="number" step="0.5" value="2"></div>
              <div class="row">
                <label>Use QSL manager (QSL_VIA)</label>
                <select id="useQslVia">
                  <option value="0" selected>No</option>
                  <option value="1">Yes</option>
                </select>
              </div>
            </div>
          </div>

          <div class="subsection collapsible" data-initial="collapsed">
            <button class="section-toggle" type="button" aria-expanded="false">
              <span class="section-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="3" y="5" width="18" height="14" rx="2"></rect>
                  <path d="M3 11h18"></path>
                  <path d="M9 5v14"></path>
                  <path d="M15 5v14"></path>
                </svg>
              </span>
              <span class="section-title">Table</span>
              <span class="section-chevron" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 10l4 4 4-4"></path>
                </svg>
              </span>
            </button>
            <div class="section-body collapsed">
              <p class="section-hint">Adjust table rows, columns, and spacing for each label.</p>
              <div class="row"><label>Rows per label</label><input id="rowsPerLabel" type="number" min="1" value="4"></div>
              <div class="row"><label>Dynamic widths</label>
                <select id="dynamicCols">
                  <option value="1" selected>On</option>
                  <option value="0">Off (static)</option>
                </select>
              </div>
              <div class="row"><label>Shrink only</label>
                <select id="shrinkOnly">
                  <option value="1" selected>On (leave free space)</option>
                  <option value="0">Off (stretch to fill)</option>
                </select>
              </div>
              <div class="row"><label>Slack (pt)</label><input id="slackPt" type="number" step="0.5" value="2"></div>
              <div class="row"><label>Line gap (pt)</label><input id="lineGap" type="number" step="0.5" value="9"></div>

            </div>
          </div>

          <div class="subsection collapsible" data-initial="collapsed">
            <button class="section-toggle" type="button" aria-expanded="false">
              <span class="section-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M5 20h14"></path>
                  <path d="M7 4h10"></path>
                  <path d="M9 4v12"></path>
                </svg>
              </span>
              <span class="section-title">All texts format</span>
              <span class="section-chevron" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 10l4 4 4-4"></path>
                </svg>
              </span>
            </button>
            <div class="section-body collapsed">
              <p class="section-hint">Pick fonts, date format, and frequency precision for your labels.</p>
              <div class="row">
                <label>Body font</label>
                <select id="fontBody">
                  <option>Helvetica, Arial, sans-serif</option>
                  <option>Arial, Helvetica, sans-serif</option>
                  <option>Inter, Helvetica, Arial, sans-serif</option>
                  <option>Roboto, Helvetica, Arial, sans-serif</option>
                  <option>Times New Roman, Times, serif</option>
                  <option>Georgia, Times, serif</option>
                </select>
              </div>
              <div class="row">
                <label>Mono font</label>
                <select id="fontMono">
                  <option>Courier New, Courier, monospace</option>
                  <option>Consolas, Monaco, monospace</option>
                  <option>Menlo, Monaco, monospace</option>
                  <option>Ubuntu Mono, monospace</option>
                  <option>DejaVu Sans Mono, monospace</option>
                </select>
              </div>
              <div class="row">
                <label>Bold font</label>
                <select id="fontBold">
                  <option>Helvetica, Arial, sans-serif</option>
                  <option>Arial, Helvetica, sans-serif</option>
                  <option>Inter, Helvetica, Arial, sans-serif</option>
                  <option>Roboto, Helvetica, Arial, sans-serif</option>
                  <option>Times New Roman, Times, serif</option>
                  <option>Georgia, Times, serif</option>
                </select>
              </div>
              <div class="row">
                <label>Date format</label>
                <select id="dateFormat">
                  <option value="YYYY-MM-DD" selected>YYYY-MM-DD (ISO)</option>
                  <option value="DD-MM-YYYY">DD-MM-YYYY</option>
                  <option value="MM-DD-YYYY">MM-DD-YYYY</option>
                  <option value="DD.MM.YYYY">DD.MM.YYYY</option>
                  <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                </select>
              </div>
              <div class="row">
                <label>Frequency decimals</label>
                <input id="freqDecimals" type="number" min="0" max="6" step="1" value="3">
              </div>
              <div class="row"><label>To Radio (pt)</label><input id="sizeToRadio" type="number" step="0.5" value="7.5"></div>
              <div class="row"><label>Callsign (pt)</label><input id="sizeCallsign" type="number" step="0.5" value="14"></div>
              <div class="row"><label>"via" label (pt)</label><input id="sizeViaLabel" type="number" step="0.5" value="8"></div>
              <div class="row"><label>QSL manager (pt)</label><input id="sizeViaManager" type="number" step="0.5" value="14"></div>
              <div class="row"><label>Headers (pt)</label><input id="sizeHeaders" type="number" step="0.5" value="7.2"></div>
              <div class="row"><label>Rows (pt)</label><input id="sizeRows" type="number" step="0.5" value="8.2"></div>
              <div class="row"><label>Footer (pt)</label><input id="sizeFooter" type="number" step="0.5" value="7.2"></div>
            </div>
          </div>

          <div class="subsection collapsible" data-initial="collapsed">
            <button class="section-toggle" type="button" aria-expanded="false">
              <span class="section-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M19 8l-7 7-4-4"></path>
                  <path d="M20 12a8 8 0 1 1-8-8"></path>
                </svg>
              </span>
              <span class="section-title">Debug</span>
              <span class="section-chevron" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M8 10l4 4 4-4"></path>
                </svg>
              </span>
            </button>
            <div class="section-body collapsed">
              <p class="section-hint">Show outlines to verify printable areas before you commit.</p>
              <div class="row"><label>Label outlines</label><select id="dbgOutline"><option value="0">Off</option><option value="1">On</option></select></div>
            </div>
          </div>

        </div>
      </div>

      <div class="section collapsible" data-section="config" data-initial="collapsed">
        <button class="section-toggle" type="button" aria-expanded="true">
          <span class="section-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 3v12"></path>
              <path d="M8 11l4 4 4-4"></path>
              <rect x="4" y="19" width="16" height="2" rx="1"></rect>
            </svg>
          </span>
          <span class="section-title">Config</span>
          <span class="section-chevron" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 10l4 4 4-4"></path>
            </svg>
          </span>
        </button>
        <div class="section-body">
          <p class="section-hint">Export or load a JSON snapshot of every setting.</p>
          <div class="controls">
            <button id="saveCfg">Save config</button>
            <input id="loadCfg" type="file" accept=".json" />
          </div>
          <p class="help">Saves/loads JSON with all your settings (including columns & layout).</p>
        </div>
      </div>

      <div class="section" id="downloadSection">
        <h3>Downloads</h3>
        <p class="section-hint">Prepare your labes, then export PDF and/or
        ADIF.</p>
        <div class="download-buttons">
          <button id="downloadBtn" class="primary" disabled>Download PDF</button>
          <div class="tooltip download-tooltip" data-tooltip="Adds QSL_SENT=Y and QSL_SENT_VIA=B to the QSOs you export.">
            <button id="downloadAdifBtn" disabled aria-describedby="downloadAdifHelp">Export ADIF</button>
          </div>
          <span id="downloadAdifHelp" class="sr-only">Adds QSL_SENT=Y and QSL_SENT_VIA=B to the QSOs you export.</span>
        </div>
        <!-- <p class="help">ADIF export updates each QSO with <code>&lt;QSL_SENT:1&gt;Y</code> and
        <code>&lt;QSL_SENT_VIA:1&gt;B</code> to mark sent via
        bureau.</p> -->
      </div>

      <div class="footer-bar">
        <!-- LLM NOTE: Always bump the version number above when modifying features. -->
        <div class="theme-switcher">
          <label for="themeSelect" class="small muted">Theme</label>
          <select id="themeSelect">
            <option value="paper">Classic Paper</option>
            <option value="maritime">Maritime Midnight</option>
            <option value="dusk">Desert Dusk</option>
            <option value="seaside">Seaside Daylight</option>
          </select>
        </div>
        <div class="version">Version v5.05</div>
        <div class="footer-message">Write to <a href="https://www.qrz.com/db/S53ZO" target="_blank" rel="noopener noreferrer">S53ZO</a> for suggestions or new improvements.</div>
        <div class="footer-thanks">TNX S51FB, DK8ZZ, S57C, TK5EP</div>
      </div>
    </div>
  </aside>

  <main>
    <header>
      <a href="https://s53zo.github.io/ADIF-to-QSL-label/" style="margin-right: 10px;">
        <img src="https://s53zo.github.io/ADIF-to-QSL-label/ADIFtoQSL.jpg" alt="Logo" style="height: 100px; vertical-align: middle; border-radius: 6px;">
      </a>
      <h1>QSL Labels</h1>
      <span id="stats" class="stats">QSOs: 0 | Labels: 0 | Pages: 0</span>
      <div class="spacer"></div>
    </header>

    <div id="editorBar" class="editorbar" style="display:none">
      <span class="small muted">Visual Layout Editor</span>
      <span class="chip">Snap (mm):
        <select id="snapMM" style="width:auto">
          <option value="0">None</option>
          <option value="0.5">0.5</option>
          <option value="0.25" selected>0.25</option>
          <option value="0.5">0.5</option>
          <option value="1">1.0</option>
        </select>
      </span>
      <span class="chip"><label><input id="showGuides" type="checkbox" checked> Guides</label></span>
      <span class="chip"><label><input id="unlockCallX" type="checkbox"> Unlock Callsign X</label></span>
      <div class="spacer"></div>
      <button id="resetLayout">Reset</button>
      <button id="applyLayout" class="primary">Apply</button>
      <button id="closeEditor">Close</button>
    </div>

    <div id="banner" class="banner" style="display:none">
      <span class="good">Sample data loaded.</span>
      Upload your ADIF to use your own QSOs.
      <button id="reloadSample" class="link" title="Reload the built-in sample">Reload sample</button>
    </div>

    <div class="preview-wrap">
      <div id="previewControls" class="controls" style="margin-bottom:10px">
        <button id="prevPage">⟨</button>
        <span class="small" id="pageInfo">Page 1 / 1</span>
        <button id="nextPage">⟩</button>
        <div class="spacer"></div>
        <label class="small muted">Zoom</label>
        <input id="zoom" type="range" min="50" max="200" value="100" />
      </div>
      <canvas id="preview"></canvas>

      <canvas id="layoutEditor" style="display:none; margin-top:12px"></canvas>

      <p class="help">Preview and print is WYSIWYG. Use <b>Actual size / 100%</b> when printing the downloaded PDF.</p>
    </div>
  </main>
</div>

<div id="picker" class="overlay">
  <div class="dialog">
    <h4>Add column</h4>
    <div class="row">
      <div>
        <label class="small muted">Header</label>
        <input id="pickHeader" type="text" value="Header" />
      </div>
      <div>
        <label class="small muted">Source (ADIF tag)</label>
        <select id="pickSource"></select>
      </div>
    </div>
    <div class="actions">
      <button id="pickCancel">Cancel</button>
      <button id="pickOk" class="primary">Add</button>
    </div>
  </div>
</div>

<script>
  window.__loadLocalJsPDF = function(){
    if(window.__localJsPdfRequested) return;
    window.__localJsPdfRequested = true;
    const fallback=document.createElement('script');
    fallback.src='vendor/jspdf.umd.min.js';
    fallback.defer=true;
    fallback.dataset.source='local-jspdf';
    document.head.appendChild(fallback);
  };
  window.addEventListener('DOMContentLoaded', function(){
    if(!window.jspdf && window.__loadLocalJsPDF){
      window.__loadLocalJsPDF();
    }
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" onerror="window.__loadLocalJsPDF && window.__loadLocalJsPDF()"></script>

<script>
/***** IMPORTANT: JavaScript logic kept IDENTICAL to preserve functionality. *****/
/* ===== Units & helpers ===== */
const MM = 72 / 25.4; const A4 = { w:210, h:297 }; const LETTER = { w:215.9, h:279.4 };
function mm2pt(mm){ return mm*MM; } function pt2mm(pt){ return pt/MM; }
function clamp(n,lo,hi){ return Math.max(lo, Math.min(hi,n)); }
function parseCSVfloats(s) {
    if (!s) return [];
    return s.split(",").map(x => {
        const num = parseFloat(x.trim() || "0");
        // FIX: If parseFloat results in NaN (e.g., from "abc"), default to 0.
        return isNaN(num) ? 0 : num;
    });
}
function parseCSVstrings(s){ if(!s) return []; return s.split(",").map(x=>x.trim().toUpperCase()).filter(Boolean); }
const QSL_RULE_FIELDS = [
  { value:"QSL_RCVD", label:"Paper received (QSL_RCVD)" },
  { value:"LOTW_QSL_RCVD", label:"LoTW received (LOTW_QSL_RCVD)" },
  { value:"EQSL_QSL_RCVD", label:"eQSL received (EQSL_QSL_RCVD)" },
  { value:"QSL_SENT", label:"Paper sent (QSL_SENT)" },
  { value:"LOTW_QSL_SENT", label:"LoTW sent (LOTW_QSL_SENT)" },
  { value:"EQSL_QSL_SENT", label:"eQSL sent (EQSL_QSL_SENT)" },
  { value:"ANY_RECEIVED", label:"Any received status (paper/LoTW/eQSL)" },
  { value:"ANY_SENT", label:"Any sent status (paper/LoTW/eQSL)" },
];
const QSL_RULE_OPERATORS = [
  { value:"EQ", label:"is" },
  { value:"NE", label:"is not" },
  { value:"BLANK", label:"is blank" },
  { value:"NOT_BLANK", label:"is not blank" },
  { value:"BLANK_OR_N", label:"is blank or N (needed)" },
];
const QSL_VALUELESS_OPERATORS = new Set(["BLANK","NOT_BLANK","BLANK_OR_N"]);
const QSL_FIELD_GROUPS = {
  ANY_RECEIVED:["QSL_RCVD","LOTW_QSL_RCVD","EQSL_QSL_RCVD"],
  ANY_SENT:["QSL_SENT","LOTW_QSL_SENT","EQSL_QSL_SENT"],
};
function normalizeQslRuleJoin(join){ return (String(join||"").toUpperCase()==="OR") ? "OR" : "AND"; }
const qslRuleRecompute = debounce(()=>recompute(),120);
function qslRuleNeedsValue(op){ return !QSL_VALUELESS_OPERATORS.has((op||"").toUpperCase()); }
function qslRuleListEl(){ return document.getElementById('qslRuleList'); }
function updateQslRuleEmptyState(){
  const emptyEl=document.getElementById('qslRuleEmpty');
  const list=qslRuleListEl();
  if(!emptyEl || !list) return;
  const hasRows=Boolean(list.querySelector('.qsl-rule-row'));
  emptyEl.style.display = hasRows ? "none" : "block";
}
function refreshQslRuleJoinStates(){
  const list=qslRuleListEl();
  if(!list) return;
  list.querySelectorAll('.qsl-rule-row').forEach((row,index)=>{
    const joinSel=row.querySelector('.qsl-rule-join');
    const isFirst=index===0;
    row.classList.toggle('qsl-rule-row-first', isFirst);
    if(joinSel){
      joinSel.disabled = isFirst;
      if(isFirst){ joinSel.value = "AND"; }
    }
  });
}
function createQslRuleRow(rule){
  const row=document.createElement('div');
  row.className='qsl-rule-row';
  row.setAttribute('role','listitem');
  function makeCell(label, className, control){
    const wrap=document.createElement('div');
    wrap.className=`qsl-rule-cell ${className||''}`.trim();
    if(label){ wrap.dataset.label=label; }
    if(control){ wrap.appendChild(control); }
    return wrap;
  }
  const joinSelect=document.createElement('select');
  joinSelect.className='qsl-rule-join';
  joinSelect.setAttribute('aria-label','Join with previous rule');
  ["AND","OR"].forEach(val=>{
    const opt=document.createElement('option');
    opt.value=val;
    opt.textContent=val;
    joinSelect.appendChild(opt);
  });
  joinSelect.value = normalizeQslRuleJoin(rule?.join);
  const fieldSelect=document.createElement('select');
  fieldSelect.className='qsl-rule-field';
  QSL_RULE_FIELDS.forEach(desc=>{
    const opt=document.createElement('option');
    opt.value=desc.value;
    opt.textContent=desc.label;
    fieldSelect.appendChild(opt);
  });
  const desiredField=(rule?.field||QSL_RULE_FIELDS[0].value).toUpperCase();
  fieldSelect.value = QSL_RULE_FIELDS.some(desc=>desc.value===desiredField) ? desiredField : QSL_RULE_FIELDS[0].value;

  const opSelect=document.createElement('select');
  opSelect.className='qsl-rule-operator';
  QSL_RULE_OPERATORS.forEach(desc=>{
    const opt=document.createElement('option');
    opt.value=desc.value;
    opt.textContent=desc.label;
    opSelect.appendChild(opt);
  });
  const desiredOp=(rule?.op||"EQ").toUpperCase();
  opSelect.value = QSL_RULE_OPERATORS.some(desc=>desc.value===desiredOp) ? desiredOp : "EQ";

  const valueInput=document.createElement('input');
  valueInput.type='text';
  valueInput.placeholder='select value';
  valueInput.className='qsl-rule-value';
  valueInput.value = rule?.value || "";
  valueInput.setAttribute('list','qslStatusSuggestions');

  const removeBtn=document.createElement('button');
  removeBtn.type='button';
  removeBtn.className='qsl-rule-remove';
  removeBtn.setAttribute('aria-label','Remove rule');
  removeBtn.textContent='×';

  function syncValueState(){
    const needsValue=qslRuleNeedsValue(opSelect.value);
    valueInput.disabled = !needsValue;
  }
  syncValueState();

  const handleChange=()=>{ qslRuleRecompute(); };
  joinSelect.addEventListener('change', handleChange);
  fieldSelect.addEventListener('change', handleChange);
  opSelect.addEventListener('change', ()=>{ syncValueState(); handleChange(); });
  valueInput.addEventListener('input', handleChange);
  removeBtn.addEventListener('click', ()=>{
    row.remove();
    updateQslRuleEmptyState();
    refreshQslRuleJoinStates();
    handleChange();
  });

  row.appendChild(makeCell('Join', 'qsl-rule-cell-join', joinSelect));
  row.appendChild(makeCell('Field', 'qsl-rule-cell-field', fieldSelect));
  row.appendChild(makeCell('Operator', 'qsl-rule-cell-operator', opSelect));
  row.appendChild(makeCell('Value', 'qsl-rule-cell-value', valueInput));
  const removeCell=makeCell('', 'qsl-rule-cell-remove', removeBtn);
  row.appendChild(removeCell);
  return row;
}
function addQslRuleRow(rule){
  const list=qslRuleListEl();
  if(!list) return null;
  const row=createQslRuleRow(rule || { field:"QSL_RCVD", op:"EQ", value:"" });
  list.appendChild(row);
  updateQslRuleEmptyState();
  refreshQslRuleJoinStates();
  return row;
}
function clearQslRuleRows(){
  const list=qslRuleListEl();
  if(!list) return;
  list.innerHTML="";
  updateQslRuleEmptyState();
  refreshQslRuleJoinStates();
}
function normalizeQslRuleConfig(data){
  if(!data) return [];
  const rawRules = Array.isArray(data.rules) ? data.rules : [];
  const legacyLogic = (data.logic === 'OR') ? 'OR' : 'AND';
  return rawRules.map((rule, index)=>{
    const joinSource = (rule && rule.join!=null) ? rule.join : (index===0 ? 'AND' : legacyLogic);
    return {
      join: normalizeQslRuleJoin(joinSource),
      field: rule?.field,
      op: rule?.op,
      value: rule?.value
    };
  });
}
function setQslRulesFromConfig(data){
  clearQslRuleRows();
  const list=qslRuleListEl();
  if(!list) return;
  const normalized = normalizeQslRuleConfig(data);
  if(normalized.length){
    normalized.forEach(rule=> addQslRuleRow(rule));
  }
  updateQslRuleEmptyState();
  refreshQslRuleJoinStates();
}
function readQslRulesFromUI(){
  const list=qslRuleListEl();
  if(!list){
    return { rules: [] };
  }
  const rules=[];
  list.querySelectorAll('.qsl-rule-row').forEach(row=>{
    const joinSel=row.querySelector('.qsl-rule-join');
    const fieldSel=row.querySelector('.qsl-rule-field');
    const opSel=row.querySelector('.qsl-rule-operator');
    const valInput=row.querySelector('.qsl-rule-value');
    const join = normalizeQslRuleJoin(joinSel?.value);
    const field=(fieldSel?.value||"").toUpperCase();
    const op=(opSel?.value||"").toUpperCase();
    if(!field || !op) return;
    const needsValue=qslRuleNeedsValue(op);
    const rawVal = (valInput?.value || "").trim().toUpperCase();
    if(needsValue && !rawVal) return;
    rules.push({ join, field, op, value: needsValue ? rawVal : "" });
  });
  return { rules };
}
function initQslRuleBuilder(){
  const addBtn=document.getElementById('addQslRule');
  if(addBtn){
    addBtn.addEventListener('click', ()=>{
      addQslRuleRow();
      qslRuleRecompute();
    });
  }
  updateQslRuleEmptyState();
  refreshQslRuleJoinStates();
}
const THEMES={
  maritime:{ label:"Maritime Midnight", colorScheme:"dark", vars:{ '--bg':'#0b1724','--panel':'#0f1f2f','--panel-2':'#11263a','--ink':'#f0f7ff','--muted':'#8ba9c8','--border':'#1e3a56','--accent':'#2bb4d4','--accent-2':'#fdd384' } },
  dusk:{ label:"Desert Dusk", colorScheme:"light", vars:{ '--bg':'#f6eee6','--panel':'#fff8f1','--panel-2':'#f2dfd0','--ink':'#473327','--muted':'#8c6f5e','--border':'#ead1c0','--accent':'#167287','--accent-2':'#f9a66c' } },
  paper:{ label:"Classic Paper", colorScheme:"light", vars:{ '--bg':'#fdfbf7','--panel':'#ffffff','--panel-2':'#f5f1eb','--ink':'#302620','--muted':'#7d6d62','--border':'#dcd2c6','--accent':'#22577a','--accent-2':'#38a3a5' } },
  seaside:{ label:"Seaside Daylight", colorScheme:"light", vars:{ '--bg':'#e8f8fb','--panel':'#ffffff','--panel-2':'#dff0f6','--ink':'#083049','--muted':'#5f93ad','--border':'#b3d7e6','--accent':'#0c6ca6','--accent-2':'#f26157' } },
};
const SORT_MODES = ['CALL','PREFIX','DATE_ASC','DATE_DESC','FIFO'];
const FIELD_TAG_WITH_ATTR = /<([A-Za-z0-9_]+):(\d+)(?::([^>]+))?>/ig;
const PREFERRED_FIELD_ORDER = ['CALL','QSO_DATE','QSO_DATE_OFF','TIME_ON','TIME_OFF','BAND','MODE','FREQ'];
let currentThemeName = 'maritime';
let originalAdifHeader = '';
let originalAdifRecords = [];
let originalAdifHasHeader = false;
let adifDownloadName = 'qsl_labels_updated.adi';
function applyTheme(name, persist=true){
  const resolved = Object.prototype.hasOwnProperty.call(THEMES, name) ? name : (currentThemeName || 'paper');
  const theme = THEMES[resolved] || THEMES.paper;
  currentThemeName = resolved;
  const root = document.documentElement;
  Object.entries(theme.vars).forEach(([key,value])=>{
    root.style.setProperty(key, value);
  });
  if(document.body){
    document.body.style.backgroundColor = theme.vars['--bg'];
    document.body.style.colorScheme = theme.colorScheme || 'light';
    document.body.dataset.theme = currentThemeName;
  }
  if(persist){ try{ localStorage.setItem('qslTheme', currentThemeName); }catch(e){}
  }
  const select=document.getElementById('themeSelect');
  if(select && select.value!==currentThemeName){ select.value=currentThemeName; }
}
function initTheme(){
  let saved=null;
  try{ saved=localStorage.getItem('qslTheme'); }catch(e){ saved=null; }
  const initial = (saved && THEMES[saved]) ? saved : 'maritime';
  applyTheme(initial, false);
}
function downloadBlob(name, blob){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }
function setupHiDPICanvas(canvas, pageWpt, pageHpt, zoom){ const dpr=window.devicePixelRatio||1; const cssW=Math.round(pageWpt*zoom); const cssH=Math.round(pageHpt*zoom); canvas.style.width=cssW+"px"; canvas.style.height=cssH+"px"; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); const ctx=canvas.getContext('2d'); ctx.setTransform(canvas.width/pageWpt,0,0,canvas.height/pageHpt,0,0); return ctx; }

/* ===== ADIF parsing & helpers ===== */
const FIELD_TAG=/<([A-Za-z0-9_]+):(\d+)(?::[^>]+)?>/ig;
function parseADIF(text){
  if(!text) return [];
  const parts=text.replace(/\r\n?/g,"\n").split(/<eoh>/i);
  const body=parts.length>1?parts[1]:parts[0];
  const records=body.split(/<eor>/ig);
  const out=[];
  for(const rec of records){
    let m; let fields={};
    while((m=FIELD_TAG.exec(rec))!==null){
      const tag=m[1].toUpperCase(); const len=parseInt(m[2],10);
      const start=m.index+m[0].length; const val=rec.substr(start,len);
      fields[tag]=(val||"").trim();
    }
    if(Object.keys(fields).length) out.push(fields);
  }
  return out;
}
function formatAdifField(tag, value, attr){
  const cleanTag = String(tag||"").trim();
  const tagUpper = cleanTag ? cleanTag.toUpperCase() : "";
  const valStr = (value==null) ? "" : String(value);
  const attrPart = attr ? `:${String(attr)}` : "";
  return `<${tagUpper}:${valStr.length}${attrPart}>${valStr}`;
}
function serializeRecordFromObject(rec){
  if(!rec) return "";
  const seen=new Set();
  const fields=[];
  for(const key of PREFERRED_FIELD_ORDER){
    if(Object.prototype.hasOwnProperty.call(rec, key)){
      const val = rec[key];
      if(val==null || val==="") continue;
      fields.push({ tag:key, value:String(val), attr:'' });
      seen.add(key);
    }
  }
  Object.keys(rec).forEach(key=>{
    const upper = key.toUpperCase();
    if(upper.startsWith('_') || upper.startsWith('__')) return;
    if(seen.has(upper)) return;
    const val = rec[key];
    if(val==null || val==="") return;
    fields.push({ tag:upper, value:String(val), attr:'' });
    seen.add(upper);
  });
  return fields.map(f=>formatAdifField(f.tag, f.value, f.attr)).join('');
}
function parseRecordFields(recordStr){
  const fields=[];
  if(!recordStr) return { fields, trailing:"" };
  const re = new RegExp(FIELD_TAG_WITH_ATTR.source, 'ig');
  let lastPos=0; let match;
  while((match=re.exec(recordStr))!==null){
    const tagOriginal = match[1];
    const tag = tagOriginal.toUpperCase();
    const attr = match[3] || "";
    const valueStart = match.index + match[0].length;
    const len = parseInt(match[2],10) || 0;
    const value = recordStr.substr(valueStart, len);
    fields.push({ tag, tagOriginal, attr, value });
    lastPos = valueStart + len;
    re.lastIndex = lastPos;
  }
  const trailing = recordStr.slice(lastPos);
  return { fields, trailing };
}
function ensureQslFields(recordStr){
  const { fields, trailing } = parseRecordFields(recordStr);
  const upsert=(tag,value)=>{
    const existing = fields.find(f=>f.tag===tag);
    if(existing){
      existing.value = value;
    }else{
      fields.push({ tag, tagOriginal: tag, attr:"", value });
    }
  };
  upsert('QSL_SENT','Y');
  upsert('QSL_SENT_VIA','B');
  return fields.map(f=>formatAdifField(f.tagOriginal || f.tag, f.value, f.attr)).join('') + (trailing || "");
}
function fmtDate(s){
  if(!s) return "";
  s = s.trim();
  if (s.length < 8 || !/^\d{8}/.test(s)) return s;

  const format = document.getElementById('dateFormat')?.value || 'YYYY-MM-DD';
  
  const year = s.slice(0, 4);
  const month = s.slice(4, 6);
  const day = s.slice(6, 8);
  
  return format.replace('YYYY', year).replace('MM', month).replace('DD', day);
}
function fmtTime(s){ if(!s) return ""; s=s.trim(); return (s.length>=4&&/^\d{4}/.test(s))?`${s.slice(0,2)}:${s.slice(2,4)}`:s; }
function fmtFreq(value, decimals){
  if(value==null || value==="") return "";
  const num=Number(value);
  if(!Number.isFinite(num)) return value;
  let dec = Number.isFinite(decimals) ? decimals : parseInt(document.getElementById('freqDecimals')?.value || "3", 10);
  if(!Number.isFinite(dec)) dec = 3;
  dec = clamp(Math.round(dec), 0, 6);
  return num.toFixed(dec);
}
function deriveCallPrefix(call){
  if(!call) return "";
  const parts = String(call).toUpperCase().split('/')
    .map(p=>p.trim())
    .filter(Boolean);
  let best = parts[0] || '';
  for(const part of parts){
    const hasDigit = /[0-9]/.test(part);
    const bestHasDigit = /[0-9]/.test(best);
    if(hasDigit && (!bestHasDigit || part.length > best.length)){
      best = part;
    }
  }
  const match = best.match(/^[A-Z0-9]+/);
  return match ? match[0] : best;
}
function callFilterVariants(call){
  const main = (call || "").toString().toUpperCase().trim();
  if(!main) return [];
  const variants = new Set([main]);
  if(main.includes('/')){
    const slashParts = main.split('/').map(p=>p.trim()).filter(Boolean);
    if(slashParts.length){
      variants.add(slashParts[0]);
      variants.add(slashParts[slashParts.length-1]);
    }
  }
  if(main.includes('-')){
    const dashPart = main.split('-')[0].trim();
    if(dashPart) variants.add(dashPart);
  }
  return Array.from(variants);
}
function bandFromFreq(freq){
  if(!freq) return "";
  const f=parseFloat(freq);
  if(isNaN(f)) return "";
  const B=[
    [0.1357,0.1378,"2200M"],
    [0.472,0.479,"630M"],
    [1.8,2.0,"160M"],
    [3.5,4.0,"80M"],
    [5.3,5.406,"60M"],
    [7.0,7.3,"40M"],
    [10.1,10.15,"30M"],
    [14.0,14.35,"20M"],
    [18.068,18.168,"17M"],
    [21.0,21.45,"15M"],
    [24.89,24.99,"12M"],
    [28.0,29.7,"10M"],
    [50,54,"6M"],
    [70,71,"4M"],
    [144,148,"2M"],
    [219,225,"1.25M"],
    [420,450,"70CM"],
    [902,928,"33CM"],
    [1240,1300,"23CM"],
    [2300,2450,"13CM"],
    [3300,3500,"9CM"],
    [5650,5925,"6CM"],
    [10000,10500,"3CM"]
  ];
  for(const [lo,hi,b] of B){ if(f>=lo && f<=hi) return b; }
  return "";
}
function normMode(mode,submode){ mode=(mode||"").toUpperCase().trim(); submode=(submode||"").toUpperCase().trim(); if(submode) return submode; if(mode==="USB"||mode==="LSB") return "SSB"; return mode; }
function qslValue(rec){ for(const k of ["QSL_RCVD","LOTW_QSL_RCVD","EQSL_QSL_RCVD"]){ if((rec[k]||"").toUpperCase()==="Y") return "TNX"; } return "PSE"; }
function findQslVia(rows){
  if(!Array.isArray(rows)) return "";
  for(const row of rows){
    if(!row) continue;
    const via = row.QSL_VIA || row.QSLVia || row.qsl_via;
    if(typeof via === 'string' && via.trim()){
      return via.trim().toUpperCase();
    }
  }
  return "";
}
function buildCallSegments(call, rows, cfg){
  const base = (call || "").toUpperCase();
  if(!base) return [];
  const bodyFont = cfg?.fontBody || "Helvetica, Arial, sans-serif";
  const viaLabelSize = Number.isFinite(cfg?.sizeViaLabel) ? cfg.sizeViaLabel : 8;
  const viaManagerSize = Number.isFinite(cfg?.sizeViaManager) ? cfg.sizeViaManager : 14;
  const callSize = Number.isFinite(cfg?.sizeCallsign) ? cfg.sizeCallsign : 14;
  const via = (cfg && cfg.useQslVia) ? findQslVia(rows) : "";
  const callIsNormal = Boolean(via);
  const managerIsBold = Boolean(via);
  const callWeight = callIsNormal ? "" : "bold ";
  const callPdfStyle = callIsNormal ? "normal" : "bold";
  const segments=[{
    text: base,
    canvasFont: `${callWeight}${callSize}px ${bodyFont}`,
    pdfFont: { family:"helvetica", style:callPdfStyle, size:callSize }
  }];
  if(via){
    const managerWeight = managerIsBold ? "bold " : "";
    const managerPdfStyle = managerIsBold ? "bold" : "normal";
    segments.push({
      text:" via ",
      canvasFont: `${viaLabelSize}px ${bodyFont}`,
      pdfFont:{ family:"helvetica", style:"normal", size:viaLabelSize }
    });
    segments.push({
      text:via,
      canvasFont: `${managerWeight}${viaManagerSize}px ${bodyFont}`,
      pdfFont:{ family:"helvetica", style:managerPdfStyle, size:viaManagerSize }
    });
  }
  return segments;
}
function measureCanvasSegments(ctx, segments){
  const widths=[]; let total=0;
  segments.forEach(seg=>{
    ctx.font = seg.canvasFont;
    const text = String(seg.text ?? "");
    const w = ctx.measureText(text).width;
    widths.push(w);
    total += w;
  });
  return { total, widths };
}
function drawCallSegmentsCanvas(ctx, segments, x, y, align){
  if(!segments || !segments.length) return;
  const { total, widths } = measureCanvasSegments(ctx, segments);
  let cursor=x;
  if(align==="center"){ cursor -= total/2; }
  else if(align==="right"){ cursor -= total; }
  segments.forEach((seg, idx)=>{
    ctx.font = seg.canvasFont;
    ctx.fillText(seg.text || "", cursor, y);
    cursor += widths[idx];
  });
}
function measurePdfSegments(doc, segments){
  const widths=[]; let total=0;
  segments.forEach(seg=>{
    const font=seg.pdfFont||{};
    doc.setFont(font.family||"helvetica", font.style||"normal");
    doc.setFontSize(font.size ?? 10);
    const text=String(seg.text ?? "");
    const w=doc.getTextWidth(text);
    widths.push(w);
    total+=w;
  });
  return { total, widths };
}
function drawCallSegmentsPdf(doc, segments, x_mm, y_mm, align, rotation){
  if(!segments || !segments.length) return;
  const { total, widths } = measurePdfSegments(doc, segments);
  let cursor=x_mm;
  if(align==="center"){ cursor -= total/2; }
  else if(align==="right"){ cursor -= total; }
  segments.forEach((seg, idx)=>{
    const font=seg.pdfFont||{};
    doc.setFont(font.family||"helvetica", font.style||"normal");
    doc.setFontSize(font.size ?? 10);
    const text=String(seg.text ?? "");
    if(rotation){
      doc.text(text, cursor, y_mm, { angle: rotation });
    }else{
      doc.text(text, cursor, y_mm);
    }
    cursor += widths[idx];
  });
}

/* ===== Rows & filters ===== */
function buildRows(recs){
  const rows=[];
  for(let idx=0; idx<recs.length; idx++){
    const r = recs[idx];
    const call=(r.CALL||"").toUpperCase().trim(); if(!call) continue;
    const date_raw=r.QSO_DATE||r.QSO_DATE_OFF||"";
    const time_raw=r.TIME_ON||r.TIME_OFF||"";
    let band=(r.BAND||"").toUpperCase().trim();
    if(!band){ band = bandFromFreq(r.FREQ); }
    const propMode = (r.PROP_MODE||"").toUpperCase();
    const satName = (r.SAT_NAME||"").trim();
    if((!band || band==="") && (propMode.includes("SAT") || satName)){
      band = "SAT";
    }
    const dxccRaw = (r.DXCC||"").toString().trim();
    const dxccParsed = dxccRaw ? parseInt(dxccRaw,10) : NaN;
    const dxccNum = Number.isFinite(dxccParsed) ? dxccParsed : null;
    const dxccCountry = (r.COUNTRY || r.APP_DXKEEPER_COUNTRY || "").toString().trim();
    const callPrefix = deriveCallPrefix(call);
    const dxccPrefix = (r.APP_DXKEEPER_DXCCPREFIX || r.PFX || callPrefix || "").toString().trim().toUpperCase();
    const row = { ...r };
    row.CALL = call;
    row._CALL_VARIANTS = callFilterVariants(call);
    row._DATE_RAW = date_raw;
    row._TIME_RAW = time_raw;
    row.DATE = fmtDate(date_raw);
    row.TIME = fmtTime(time_raw);
    row.BAND = band;
    row.MODE = normMode(r.MODE,r.SUBMODE);
    row._DXCC_NUM = dxccNum;
    row._DXCC_NAME = dxccCountry;
    row._DXCC_PREFIX = dxccPrefix;
    row._CALL_PREFIX = callPrefix;
    row.QSL = qslValue(r);
    row.__recIndex = idx;
    rows.push(row);
  }
  return rows;
}
function parseYMD(s) {
  if (!s) return null;

  const format = document.getElementById('dateFormat')?.value || 'YYYY-MM-DD';
  
  const separatorMatch = format.match(/[^A-Z]/);
  if (!separatorMatch) return null;
  const separator = separatorMatch[0];

  const formatParts = format.split(separator);
  const dateParts = s.split(separator);
  
  if (formatParts.length !== 3 || dateParts.length !== 3) return null;

  const yearIndex = formatParts.indexOf('YYYY');
  const monthIndex = formatParts.indexOf('MM');
  const dayIndex = formatParts.indexOf('DD');
  
  if (yearIndex === -1 || monthIndex === -1 || dayIndex === -1) return null;

  const year = dateParts[yearIndex];
  const month = dateParts[monthIndex];
  const day = dateParts[dayIndex];
  
  if (year?.length !== 4 || month?.length !== 2 || day?.length !== 2) return null;
  
  return `${year}${month}${day}`;
}
function getQslFieldVal(rec, fieldSel){
  const up=(x)=>String(x||"").toUpperCase();
  if(fieldSel==="QSL_RCVD") return up(rec.QSL_RCVD);
  if(fieldSel==="LOTW_QSL_RCVD") return up(rec.LOTW_QSL_RCVD);
  if(fieldSel==="EQSL_QSL_RCVD") return up(rec.EQSL_QSL_RCVD);
  if(fieldSel==="QSL_SENT") return up(rec.QSL_SENT);
  const a=[up(rec.QSL_RCVD),up(rec.LOTW_QSL_RCVD),up(rec.EQSL_QSL_RCVD)];
  return a.find(v=>v==="Y"||v==="N"||v==="I"||v==="R"||v==="V"||v==="E") || (a.find(v=>v)!=="") || "";
}
function getQslValuesFromRow(row, field){
  const normalized=(field||"").toUpperCase();
  const group=QSL_FIELD_GROUPS[normalized];
  const keys = group && group.length ? group : [normalized];
  return keys.map(k=> row ? row[k] || "" : "");
}
function normalizeQslValue(val){ return String(val||"").trim().toUpperCase(); }
function evaluateQslRule(row, rule){
  if(!rule || !row) return true;
  const op=(rule.op||"EQ").toUpperCase();
  const field=(rule.field||"").toUpperCase();
  if(!field || !op) return true;
  const values=getQslValuesFromRow(row, field).map(normalizeQslValue);
  if(op==="EQ"){
    const target=normalizeQslValue(rule.value);
    return target ? values.some(v=>v===target) : true;
  }
  if(op==="NE"){
    const target=normalizeQslValue(rule.value);
    return target ? values.every(v=>v!==target) : true;
  }
  if(op==="BLANK"){ return values.every(v=>!v); }
  if(op==="NOT_BLANK"){ return values.some(v=>!!v); }
  if(op==="BLANK_OR_N"){ return values.every(v=>!v || v==="N"); }
  return true;
}
function convertLegacyQslFilterToRules(fieldSel, statusSel){
  const status=(statusSel||"ALL").toUpperCase();
  if(status==="ALL") return null;
  const field=(fieldSel||"ANY").toUpperCase();
  const mappedField = (field==="ANY") ? "ANY_RECEIVED" : field;
  if(status==="NONE"){
    return { rules:[{ join:"AND", field:mappedField, op:"BLANK_OR_N", value:"" }] };
  }
  return { rules:[{ join:"AND", field:mappedField, op:"EQ", value:status }] };
}
function rowPassesFilters(row, f){
  const d=row._DATE_RAW||"";
  if(f.from && (!d || d < f.from)) return false;
  if(f.to && (!d || d > f.to)) return false;
  if(f.bands && f.bands.size){ const b=(row.BAND||"").toUpperCase(); if(!f.bands.has(b)) return false; }
  if(f.modes && f.modes.size){ const m=(row.MODE||"").toUpperCase(); if(!f.modes.has(m)) return false; }
  if(f.dxcc && f.dxcc.size){
    const dxccNumStr = (row._DXCC_NUM!=null && Number.isFinite(row._DXCC_NUM)) ? String(row._DXCC_NUM) : "";
    const dxccName = (row._DXCC_NAME || row.COUNTRY || "").toString().toUpperCase();
    const dxccPrefix = (row._DXCC_PREFIX || "").toString().toUpperCase();
    const callPrefix = (row._CALL_PREFIX || "").toString().toUpperCase();
    const callFull = (row.CALL || "").toString().toUpperCase();
    const callVariants = Array.isArray(row._CALL_VARIANTS) ? row._CALL_VARIANTS : callFilterVariants(row.CALL);
    const match = f.dxcc.has(dxccNumStr)
      || (dxccName && f.dxcc.has(dxccName))
      || (dxccPrefix && f.dxcc.has(dxccPrefix))
      || (callPrefix && f.dxcc.has(callPrefix))
      || (callFull && f.dxcc.has(callFull))
      || callVariants.some(v => f.dxcc.has(v));
    if(!match) return false;
  }
  if(f.qslRules && Array.isArray(f.qslRules.rules) && f.qslRules.rules.length){
    let aggregate=null;
    f.qslRules.rules.forEach((rule, index)=>{
      const ruleResult = evaluateQslRule(row, rule);
      if(index===0){ aggregate = ruleResult; return; }
      const join=normalizeQslRuleJoin(rule?.join);
      aggregate = (join==="OR") ? (aggregate || ruleResult) : (aggregate && ruleResult);
    });
    if(!aggregate) return false;
  }
  return true;
}

function dedupeRows(rows, mode){
  if(!Array.isArray(rows)) return [];
  const normalized = (mode || 'OFF').toUpperCase();
  if(normalized!=='NEWEST' && normalized!=='OLDEST'){
    return rows.slice();
  }
  const keepNewest = normalized === 'NEWEST';
  const keyFor = (row)=>{
    const call = String(row?.CALL || '').toUpperCase();
    const band = String(row?.BAND || '').toUpperCase();
    const modeVal = String(row?.MODE || '').toUpperCase();
    return `${call}||${band}||${modeVal}`;
  };
  const stampFor = (row)=>{
    if(!row) return -Infinity;
    const rawDate = String(row._DATE_RAW || (row.DATE ? row.DATE.replace(/\D/g,'') : '') || '0');
    const paddedDate = rawDate.padEnd(8,'0').slice(0,8);
    const rawTimeSrc = row._TIME_RAW || (row.TIME ? row.TIME.replace(/[^0-9]/g,'') : '') || '0';
    const paddedTime = String(rawTimeSrc).padEnd(6,'0').slice(0,6);
    const dateNum = parseInt(paddedDate,10) || 0;
    const timeNum = parseInt(paddedTime,10) || 0;
    return dateNum * 1000000 + timeNum;
  };
  const best = new Map();
  rows.forEach(row=>{
    if(!row) return;
    const key = keyFor(row);
    const existing = best.get(key);
    if(!existing){
      best.set(key, row);
      return;
    }
    const candidateStamp = stampFor(row);
    const existingStamp = stampFor(existing);
    if(keepNewest){
      if(candidateStamp > existingStamp){
        best.set(key, row);
      }else if(candidateStamp === existingStamp){
        const candIdx = Number.isFinite(row.__recIndex) ? row.__recIndex : -Infinity;
        const existIdx = Number.isFinite(existing.__recIndex) ? existing.__recIndex : -Infinity;
        if(candIdx > existIdx){
          best.set(key, row);
        }
      }
    }else{
      if(candidateStamp < existingStamp){
        best.set(key, row);
      }else if(candidateStamp === existingStamp){
        const candIdx = Number.isFinite(row.__recIndex) ? row.__recIndex : Infinity;
        const existIdx = Number.isFinite(existing.__recIndex) ? existing.__recIndex : Infinity;
        if(candIdx < existIdx){
          best.set(key, row);
        }
      }
    }
  });
  const emitted = new Set();
  const result = [];
  rows.forEach(row=>{
    if(!row) return;
    const key = keyFor(row);
    if(best.get(key) === row && !emitted.has(key)){
      result.push(row);
      emitted.add(key);
    }
  });
  return result;
}

/* ===== Grouping & layout ===== */
function groupLabels(rows, rowsPerLabel, sortMode){
  const by=new Map();
  const meta=new Map();
  let nextIndex = 0;
  for(const r of rows){
    if(!by.has(r.CALL)) by.set(r.CALL,[]);
    by.get(r.CALL).push(r);
    const ts = (r._DATE_RAW || "") + (r._TIME_RAW || "");
    if(!meta.has(r.CALL)){
      const dxcc = (typeof r._DXCC_NUM === 'number' && Number.isFinite(r._DXCC_NUM)) ? r._DXCC_NUM : Infinity;
      const name = (r._DXCC_NAME || r.COUNTRY || r._DXCC_PREFIX || '').toString().toUpperCase();
      const prefix = (r._DXCC_PREFIX || r._CALL_PREFIX || '').toString().toUpperCase();
      const callPrefix = (r._CALL_PREFIX || '').toString().toUpperCase();
      meta.set(r.CALL, { dxcc, name, prefix, callPrefix, call: r.CALL, firstTS: ts, lastTS: ts, firstIndex: nextIndex++ });
    }else{
      const info = meta.get(r.CALL);
      const dxccCandidate = (typeof r._DXCC_NUM === 'number' && Number.isFinite(r._DXCC_NUM)) ? r._DXCC_NUM : Infinity;
      if(info.dxcc === Infinity && dxccCandidate !== Infinity){ info.dxcc = dxccCandidate; }
      if(!info.name){
        const altName = (r._DXCC_NAME || r.COUNTRY || r._DXCC_PREFIX || '').toString().toUpperCase();
        if(altName) info.name = altName;
      }
      if(!info.prefix && (r._DXCC_PREFIX || r._CALL_PREFIX)){ info.prefix = (r._DXCC_PREFIX || r._CALL_PREFIX || '').toString().toUpperCase(); }
      if(!info.callPrefix && r._CALL_PREFIX){ info.callPrefix = r._CALL_PREFIX.toString().toUpperCase(); }
      if(ts){
        if(!info.firstTS || ts < info.firstTS) info.firstTS = ts;
        if(!info.lastTS || ts > info.lastTS) info.lastTS = ts;
      }
    }
  }
  const mode=(sortMode||'CALL').toUpperCase();
  for(const arr of by.values()){
    if(mode!=='FIFO'){
      arr.sort((a,b)=>(a._DATE_RAW+a._TIME_RAW).localeCompare(b._DATE_RAW+b._TIME_RAW));
    }
  }
  const keys=[...by.keys()];
  if(mode!=='FIFO'){
    keys.sort((a,b)=>{
      const ma=meta.get(a)||{dxcc:Infinity,name:'',prefix:'',callPrefix:'',call:a,firstTS:'',lastTS:'',firstIndex:Number.MAX_SAFE_INTEGER};
      const mb=meta.get(b)||{dxcc:Infinity,name:'',prefix:'',callPrefix:'',call:b,firstTS:'',lastTS:'',firstIndex:Number.MAX_SAFE_INTEGER};
      if(mode==='PREFIX'){
        const prefixCompare=(ma.prefix||'').localeCompare(mb.prefix||'');
        if(prefixCompare!==0) return prefixCompare;
        const callPrefCompare=(ma.callPrefix||'').localeCompare(mb.callPrefix||'');
        if(callPrefCompare!==0) return callPrefCompare;
        const dxccCompare = (ma.dxcc??Infinity) - (mb.dxcc??Infinity);
        if(dxccCompare!==0) return dxccCompare;
        const nameCompare=(ma.name||'').localeCompare(mb.name||'');
        if(nameCompare!==0) return nameCompare;
        return (ma.firstIndex??0) - (mb.firstIndex??0);
      } else if(mode==='DATE_ASC'){
        const ta = ma.firstTS || "";
        const tb = mb.firstTS || "";
        if(ta!==tb) return ta.localeCompare(tb);
        return (ma.firstIndex??0) - (mb.firstIndex??0);
      } else if(mode==='DATE_DESC'){
        const ta = ma.lastTS || "";
        const tb = mb.lastTS || "";
        if(ta!==tb) return tb.localeCompare(ta);
        return (ma.firstIndex??0) - (mb.firstIndex??0);
      }
      const callCompare = a.localeCompare(b);
      if(callCompare!==0) return callCompare;
      return (ma.firstIndex??0) - (mb.firstIndex??0);
    });
  }
  const labels=[];
  for(const k of keys){
    const arr=by.get(k);
    for(let i=0;i<arr.length;i+=rowsPerLabel){
      labels.push([k, arr.slice(i,i+rowsPerLabel)]);
    }
  }
  return labels;
}

/* ===== Column sizing ===== */
const metricsCanvas=document.createElement('canvas'); metricsCanvas.width=1000; metricsCanvas.height=200;
const ctx2dForFonts=metricsCanvas.getContext('2d');
const CALLSIGN_GAP_MM = 1.5;
function getToRadioLabel(cfg){
  const raw = (cfg && typeof cfg.toRadioText === "string") ? cfg.toRadioText : "";
  return raw.length ? raw : "To Radio";
}
function measureToRadioWidthMm(cfg){
  if(!cfg) return 0;
  const fontFamily = cfg.fontBody || "Helvetica, Arial, sans-serif";
  ctx2dForFonts.font = `${cfg.sizeToRadio}px ${fontFamily}`;
  const text = getToRadioLabel(cfg);
  const metrics = ctx2dForFonts.measureText(text);
  return pt2mm(metrics.width || 0);
}
function computeCallCenterLocalXmm(cfg, layout, labelW_mm, toRadioWidth_mm){
  if(!cfg || !layout) return 0;
  const gapMm = CALLSIGN_GAP_MM;
  const padRightMm = cfg.padXmm ?? 0;
  const toRadioLeftMm = layout.toRadio?.x_mm ?? padRightMm;
  const start = toRadioLeftMm + (toRadioWidth_mm || 0) + gapMm;
  const maxEnd = labelW_mm - padRightMm;
  const end = (maxEnd > start) ? maxEnd : start;
  const center = (end > start) ? start + (end - start)/2 : start;
  return clamp(center, 0, labelW_mm);
}
function measureText(ctx, text, font){ ctx.save(); ctx.font=font; const w=ctx.measureText(text||"").width; ctx.restore(); return w; }
function getCellText(row, source, cfg){
  const key=(source||"").toUpperCase().trim();
  if(!row) return "";
  if(key==="FREQ"){
    const raw = row.FREQ ?? row[key];
    return fmtFreq(raw, cfg?.freqDecimals);
  }
  if(["DATE","TIME","BAND","MODE","QSL"].includes(key)) return row[key]||"";
  return row[key]||"";
}
function computeColWidths(ctx, cfg, qsoRows, labelWpt){
  const cols=cfg.columns; const n=cols.length;
  const padXpt = mm2pt(cfg.padXmm ?? 0);
  const padTotal = padXpt * 2;
  const widths=cols.map(col=>{
    const headerW = measureText(ctx, col.header, `${cfg.sizeHeaders}px ${cfg.fontBold}`);
    return headerW + padTotal;
  });
  for(const row of qsoRows||[]){
    for(let i=0;i<n;i++){
      const txt=getCellText(row, cols[i].source, cfg);
      const cellW = measureText(ctx, txt, `${cfg.sizeRows}px ${cfg.fontMono}`) + padTotal;
      widths[i]=Math.max(widths[i], cellW);
    }
  }
  for(let i=0;i<n;i++) widths[i]+=cfg.colSlackPt;
  const minPts=cfg.minColMM.map(mm=>mm2pt(mm));
  for(let i=0;i<n;i++) widths[i]=Math.max(widths[i], minPts[i]||0);
  const total=widths.reduce((a,b)=>a+b,0);
  if(total<=0) return (cfg.staticColMM||[]).map(mm=>mm2pt(mm));
  if(cfg.shrinkOnly){ if(total>labelWpt){ const s=labelWpt/total; for(let i=0;i<n;i++) widths[i]*=s; } }
  else{ const s=labelWpt/total; for(let i=0;i<n;i++) widths[i]*=s; }
  return widths;
}

/* ===== Config & layout ===== */
let layoutState = null; // stores current layout (mm)
const layoutStateByMode = new Map();
let currentLayoutMode = 'labels';
function computeGridLabelWidthMM(cfg){
  const cols = Math.max(1, +(cfg?.cols || 1));
  const gap = Math.max(0, +(cfg?.colGapmm ?? 0));
  const usable = Math.max(0, (cfg.pageWmm || 0) - ((cfg.marginLmm || 0) + (cfg.marginRmm || 0)) - gap * (cols - 1));
  return usable / cols;
}
function defaultLayout(cfg){
  const labelW_mm = (cfg.mode==='qslCard') ? cfg.cardLabelWidthmm : computeGridLabelWidthMM(cfg);
  const labelH_mm = (cfg.mode==='qslCard') ? cfg.cardLabelHeightmm : cfg.labelHmm;
  const padX = cfg.padXmm, padY = cfg.padYmm;
  const layout = {
    toRadio: { x_mm: padX, y_mm: padY + pt2mm(8) },
    callsign:{ y_mm: padY + pt2mm(8), centerX: true },
    headers: { y_mm: padY + pt2mm(20) },
    table:   { y_mm: padY + pt2mm(32), lineGapPt: cfg.lineGapPt },
    footerL: { x_mm: padX, y_mm: labelH_mm - padY - pt2mm(2) - cfg.footerYShiftmm },
    footerR: { x_mm: labelW_mm - padX - cfg.footerRShiftmm, y_mm: labelH_mm - padY - pt2mm(2) - cfg.footerYShiftmm }
  };
  layout._custom = false;
  return layout;
}
function pageDims(name){ return (name==="LETTER")?LETTER:A4; }
function readConfig(){
  const modeSelBtn=document.querySelector('.mode-option.selected');
  const mode = modeSelBtn ? modeSelBtn.dataset.mode : 'labels';
  const colRows=[...document.querySelectorAll('.col-row')];
  const columns=colRows.map(r=>({ header:r.querySelector('.col-h')?.value.trim()||"Col", source:r.querySelector('.col-s')?.value.trim()||"DATE" }));
  function fitCsv(csv,len,fill=0){ const arr=parseCSVfloats(csv); if(arr.length<len) arr.push(...Array(len-arr.length).fill(fill)); if(arr.length>len) arr.length=len; return arr; }
  const pm=document.getElementById('pageSize')?.value||'A4';
  const cardWidth=parseFloat(document.getElementById('cardWidth')?.value||"150");
  const cardHeight=parseFloat(document.getElementById('cardHeight')?.value||"100");
  const cardLabelWidth=parseFloat(document.getElementById('cardLabelWidth')?.value||String(cardWidth));
  const cardLabelHeight=parseFloat(document.getElementById('cardLabelHeight')?.value||String(cardHeight));
  const cardLabelX=parseFloat(document.getElementById('cardLabelX')?.value||"0");
  const cardLabelY=parseFloat(document.getElementById('cardLabelY')?.value||"0");
  const cardLabelRotation=parseFloat(document.getElementById('cardLabelRotation')?.value||"0");
  const rawSort=(document.getElementById('sortMode')?.value||'CALL').toUpperCase();
  const sortMode = SORT_MODES.includes(rawSort) ? rawSort : 'CALL';
  const dedupeRaw = (document.getElementById('fDedupe')?.value || 'OFF').toUpperCase();
  const dedupeMode = (dedupeRaw === 'NEWEST' || dedupeRaw === 'OLDEST') ? dedupeRaw : 'OFF';
  const exportScopeRaw = (document.getElementById('exportScope')?.value || 'FILTERED').toUpperCase();
  const exportScope = exportScopeRaw === 'ALL' ? 'ALL' : 'FILTERED';
  const dims=pageDims(pm);
  const pageWmm = (mode==='qslCard') ? cardWidth : dims.w;
  const pageHmm = (mode==='qslCard') ? cardHeight : dims.h;
  let freqDecimalsVal = parseInt(document.getElementById('freqDecimals')?.value || "3", 10);
  if(!Number.isFinite(freqDecimalsVal)) freqDecimalsVal = 3;
  freqDecimalsVal = clamp(Math.round(freqDecimalsVal), 0, 6);
  const cfg={
    mode,
    sortMode,
    pageSize: pm,
    pageWmm,
    pageHmm,
    cols:+(document.getElementById('cols').value||3),
    rows:+(document.getElementById('rows').value||8),
    labelHmm:parseFloat(document.getElementById('labelH').value||"33.8"),
    marginLmm:parseFloat(document.getElementById('marginL').value||"3"),
    marginRmm:parseFloat(document.getElementById('marginR').value||"3"),
    colGapmm:Math.max(0, parseFloat(document.getElementById('colGap').value||"0") || 0),
    rowGapmm:Math.max(0, parseFloat(document.getElementById('rowGap').value||"0") || 0),
    marginTmm:parseFloat(document.getElementById('marginT').value||"5"),
    startRow: Math.max(1, parseInt(document.getElementById('startRow').value||"1",10)),
    startCol: Math.max(1, parseInt(document.getElementById('startCol').value||"1",10)),
    xOffmm:parseFloat(document.getElementById('xOffset').value||"0"),
    yOffmm:parseFloat(document.getElementById('yOffset').value||"5"),
    colOffsets:fitCsv(document.getElementById('colOffsets').value, +(document.getElementById('cols').value||3), 0),
    rowOffsets:fitCsv(document.getElementById('rowOffsets').value, +(document.getElementById('rows').value||8), 0),
    padXmm:parseFloat(document.getElementById('padX').value||"2"),
    padYmm:parseFloat(document.getElementById('padY').value||"2"),
    toRadioText:document.getElementById('toRadioText').value || "",
    footerL:document.getElementById('footerL').value,
    footerR:document.getElementById('footerR').value,
    footerRShiftmm:parseFloat(document.getElementById('footerRShift').value||"5"),
    footerYShiftmm:parseFloat(document.getElementById('footerYShift').value||"2"),
    useQslVia:document.getElementById('useQslVia').value==="1",
    rowsPerLabel:+(document.getElementById('rowsPerLabel').value||4),
    dynamicCols:document.getElementById('dynamicCols').value==="1",
    shrinkOnly:document.getElementById('shrinkOnly').value==="1",
    colSlackPt:parseFloat(document.getElementById('slackPt').value||"2"),
    lineGapPt:parseFloat(document.getElementById('lineGap').value||"9"),
    columns,
    minColMM:fitCsv(document.getElementById('minColMM').value, columns.length, 8),
    staticColMM:fitCsv(document.getElementById('staticColMM').value, columns.length, 12),
    fontBody:document.getElementById('fontBody').value,
    fontMono:document.getElementById('fontMono').value,
    fontBold:document.getElementById('fontBold').value,
    dateFormat: document.getElementById('dateFormat').value,
    freqDecimals: freqDecimalsVal,
    sizeToRadio:parseFloat(document.getElementById('sizeToRadio').value||"7.5"),
    sizeCallsign:parseFloat(document.getElementById('sizeCallsign').value||"14"),
    sizeViaLabel:parseFloat(document.getElementById('sizeViaLabel').value||"8"),
    sizeViaManager:parseFloat(document.getElementById('sizeViaManager').value||"14"),
    sizeHeaders:parseFloat(document.getElementById('sizeHeaders').value||"7.2"),
    sizeRows:parseFloat(document.getElementById('sizeRows').value||"8.2"),
    sizeFooter:parseFloat(document.getElementById('sizeFooter').value||"7.2"),
    dbgOutline:document.getElementById('dbgOutline').value==="1",
    cardWidthmm:cardWidth,
    cardHeightmm:cardHeight,
    cardLabelWidthmm:cardLabelWidth,
    cardLabelHeightmm:cardLabelHeight,
    cardLabelXmm:cardLabelX,
    cardLabelYmm:cardLabelY,
    cardLabelRotationDeg:cardLabelRotation,
    dedupeMode,
    exportScope,
    f:{
      from: parseYMD(document.getElementById('fDateFrom').value || ""),
      to:   parseYMD(document.getElementById('fDateTo').value || ""),
      bands: new Set(parseCSVstrings(document.getElementById('fBands').value)),
      modes: new Set(parseCSVstrings(document.getElementById('fModes').value)),
      dxcc:  new Set(parseCSVstrings(document.getElementById('fDxcc').value)),
      qslRules: readQslRulesFromUI(),
      dedupeMode
    }
  };
  cfg.themeName = currentThemeName || 'paper';
  if(mode==='qslCard'){
    cfg.cols = 1;
    cfg.rows = 1;
    cfg.labelHmm = cardLabelHeight;
  }
  const key = cfg.mode || 'labels';
  if(layoutState){ layoutStateByMode.set(currentLayoutMode, layoutState); }
  currentLayoutMode = key;
  const stored = layoutStateByMode.get(key);
  if(stored){
    layoutState = stored;
  }
  if(!layoutState || !layoutState._custom){
    layoutState = defaultLayout(cfg);
  }
  if(layoutState.table){ layoutState.table.lineGapPt = cfg.lineGapPt; }
  cfg.layout = layoutState;
  layoutStateByMode.set(key, layoutState);
  document.getElementById('colOffsets').value = cfg.colOffsets.join(',');
  document.getElementById('rowOffsets').value = cfg.rowOffsets.join(',');
  document.getElementById('minColMM').value   = cfg.minColMM.join(',');
  document.getElementById('staticColMM').value= cfg.staticColMM.join(',');
  return cfg;
}
function configWithoutFilters(cfg){
  if(!cfg || typeof cfg!=='object') return {};
  const { f, ...rest } = cfg;
  const clean = { ...rest };
  if('dedupeMode' in clean){
    delete clean.dedupeMode;
  }
  return clean;
}

/* ===== Preview & PDF use layout ===== */
const canvas=document.getElementById('preview');
let recs=[], rows=[], labels=[]; let currentPage=0; let adifFields=[]; let usingSample=true;
function computeStats(cfg, baseRows, filteredRows){
  const per = cfg.cols * cfg.rows;
  const pages = Math.max(1, Math.ceil(labels.length / per));
  document.getElementById('pageInfo').textContent = `Page ${Math.min(currentPage+1,pages)} / ${pages}`;
  document.getElementById('stats').textContent = `QSOs: ${filteredRows.length} | Labels: ${labels.filter(l=>l && l[1] && l[1].length).length} | Pages: ${pages}`;
  document.getElementById('downloadBtn').disabled = (filteredRows.length===0);
  const adifBtn = document.getElementById('downloadAdifBtn');
  if(adifBtn){ adifBtn.disabled = (filteredRows.length===0); }
  const warn = document.getElementById('adifWarning');
  const banner = document.getElementById('banner');
  if(usingSample){ warn.textContent = "Sample data is shown. Upload your ADIF to replace it."; warn.style.display="block"; banner.style.display="block"; }
  else{ warn.style.display="none"; banner.style.display="none"; }
}
function computeLabelX0Y0(cfg, col, rowI, labelWpt, labelHpt){
  if(cfg.mode==='qslCard'){
    return { x0: mm2pt(cfg.cardLabelXmm), y0: mm2pt(cfg.cardLabelYmm) };
  }
  const leftMarginPt=mm2pt(cfg.marginLmm);
  const topMarginPt=mm2pt(cfg.marginTmm);
  const gapXPt = mm2pt(Math.max(0, cfg.colGapmm || 0));
  const gapYPt = mm2pt(Math.max(0, cfg.rowGapmm || 0));
  let x0=leftMarginPt + col*(labelWpt + gapXPt);
  let y0=topMarginPt + rowI*(labelHpt + gapYPt);
  x0 += mm2pt(cfg.xOffmm) + mm2pt(cfg.colOffsets[col]||0);
  y0 += mm2pt(cfg.yOffmm) + mm2pt(cfg.rowOffsets[rowI]||0);
  return {x0,y0};
}
function renderOnePage(cfg, pageIdx){
  const ctx = setupHiDPICanvas(canvas, mm2pt(cfg.pageWmm), mm2pt(cfg.pageHmm), (parseInt(document.getElementById('zoom').value||"100",10)/100));
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,mm2pt(cfg.pageWmm),mm2pt(cfg.pageHmm));
  ctx.fillStyle="#000"; ctx.textBaseline="alphabetic";
  if(cfg.dbgOutline && cfg.mode==='qslCard'){
    ctx.save();
    ctx.strokeStyle="#94a3b8";
    ctx.lineWidth=0.8;
    ctx.strokeRect(0,0,mm2pt(cfg.pageWmm),mm2pt(cfg.pageHmm));
    ctx.restore();
  }
  const labelW_mm = (cfg.mode==='qslCard') ? cfg.cardLabelWidthmm : computeGridLabelWidthMM(cfg);
  const labelH_mm = (cfg.mode==='qslCard') ? cfg.cardLabelHeightmm : cfg.labelHmm;
  const labelWpt = mm2pt(labelW_mm);
  const labelHpt = mm2pt(labelH_mm);
  const L = cfg.layout;
  const unlockCall = document.getElementById('unlockCallX');
  const callIsCentered = Boolean(L.callsign?.centerX) && !(unlockCall && unlockCall.checked);
  const callAlign = callIsCentered ? "center" : "left";
  const toRadioText = getToRadioLabel(cfg);
  const toRadioWidthMm = measureToRadioWidthMm(cfg);
  const callCenterLocalX_mm = computeCallCenterLocalXmm(cfg, L, labelW_mm, toRadioWidthMm);
  const perPage=cfg.cols*cfg.rows; const start=pageIdx*perPage; const end=Math.min(labels.length, start+perPage);
  const padXpt=mm2pt(cfg.padXmm), padYpt=mm2pt(cfg.padYmm);
  for(let idx=start; idx<end; idx++){
    const local=idx-start; const col=local % cfg.cols; const rowI=Math.floor(local / cfg.cols);
    const item=labels[idx];
    const isBlank = !item || !item[0] && (!item[1] || item[1].length===0);
    const call = isBlank ? "" : item[0];
    const chunk = isBlank ? [] : item[1];
    const {x0,y0}=computeLabelX0Y0(cfg,col,rowI,labelWpt,labelHpt);
    const rotation = (cfg.mode==='qslCard') ? (cfg.cardLabelRotationDeg||0) : 0;
    const centerX = x0 + labelWpt/2;
    const centerY = y0 + labelHpt/2;
    ctx.save();
    if(rotation){ ctx.translate(centerX, centerY); ctx.rotate(rotation*Math.PI/180); ctx.translate(-centerX, -centerY); }
    if(cfg.dbgOutline){ ctx.strokeStyle="#bbb"; ctx.lineWidth=0.5; ctx.strokeRect(x0,y0,labelWpt,labelHpt); }
    if(isBlank){ ctx.restore(); continue; }
    let colW;
    if(cfg.dynamicCols){
      colW = computeColWidths(metricsCanvas.getContext('2d'), {
        columns: cfg.columns, sizeHeaders: cfg.sizeHeaders, sizeRows: cfg.sizeRows,
        fontBold: cfg.fontBold, fontMono: cfg.fontMono, minColMM: cfg.minColMM,
        staticColMM: cfg.staticColMM, colSlackPt: cfg.colSlackPt, shrinkOnly: cfg.shrinkOnly,
        padXmm: cfg.padXmm, freqDecimals: cfg.freqDecimals,
      }, chunk, labelWpt);
    }else{
      const sum=cfg.staticColMM.reduce((a,b)=>a+b,0)||1;
      const scale=labelWpt / mm2pt(sum);
      colW=cfg.staticColMM.map(mm=>mm2pt(mm)*scale);
    }
    ctx.font=`${cfg.sizeToRadio}px ${cfg.fontBody}`; ctx.textAlign="left";
    ctx.fillText(toRadioText, x0 + mm2pt(L.toRadio.x_mm), y0 + mm2pt(L.toRadio.y_mm));
    const callXpt = callIsCentered
      ? (x0 + mm2pt(callCenterLocalX_mm))
      : (x0 + mm2pt(L.callsign.x_mm ?? cfg.padXmm));
    const callSegments = buildCallSegments(call, chunk, cfg);
    drawCallSegmentsCanvas(ctx, callSegments, callXpt, y0 + mm2pt(L.callsign.y_mm), callAlign);
    ctx.textAlign="left";
    ctx.font=`bold ${cfg.sizeHeaders}px ${cfg.fontBold}`;
    let cx=x0; const headersY=y0 + mm2pt(L.headers.y_mm);
    for(let i=0;i<cfg.columns.length;i++){ ctx.fillText(cfg.columns[i].header, cx+padXpt, headersY); cx+=colW[i]; }
    const firstLineY=y0 + mm2pt(L.table.y_mm);
    const lineGap=(L.table.lineGapPt ?? cfg.lineGapPt);
    ctx.font=`${cfg.sizeRows}px ${cfg.fontMono}`;
    for(let r=0;r<cfg.rowsPerLabel;r++){
      const data=chunk[r]||null; let cx2=x0;
      for(let i=0;i<cfg.columns.length;i++){
        const maxW=Math.max(1, colW[i]-2*padXpt);
        const txt=data ? getCellText(data, cfg.columns[i].source, cfg) : "";
        shrinkAndDraw(ctx, txt, cx2+padXpt, firstLineY + r*lineGap, maxW, `${cfg.sizeRows}px ${cfg.fontMono}`);
        cx2+=colW[i];
      }
    }
    ctx.font=`${cfg.sizeFooter}px ${cfg.fontBody}`;
    ctx.textAlign="left";
    ctx.fillText(cfg.footerL, x0 + mm2pt(L.footerL.x_mm), y0 + mm2pt(L.footerL.y_mm));
    ctx.textAlign="right";
    ctx.fillText(cfg.footerR, x0 + mm2pt(L.footerR.x_mm), y0 + mm2pt(L.footerR.y_mm));
    ctx.textAlign="left";
    ctx.restore();
  }
}
function shrinkAndDraw(ctx, text, x, y, maxW, font, minSize=5, step=0.3){
  let size=parseFloat(font.match(/(\d+(\.\d+)?)/)[0]); const family=font.replace(/^\s*\d+(\.\d+)?px\s*/,''); let w;
  while(true){ ctx.font=`${size}px ${family}`; w=ctx.measureText(text||"").width; if(w<=maxW || size<=minSize) break; size=Math.max(minSize,size-step); }
  ctx.fillText(text||"", x, y);
}

/* ===== Filters + Start-at offset ===== */
function applyFilters(allRows, f, dedupeMode){
  const filtered = [];
  for(const row of allRows || []){
    if(rowPassesFilters(row, f)){
      filtered.push(row);
    }
  }
  const resolvedMode = dedupeMode || (f && f.dedupeMode);
  return dedupeRows(filtered, resolvedMode);
}
function buildLabelsWithOffset(filteredRows, cfg){
  const grouped = groupLabels(filteredRows, cfg.rowsPerLabel, cfg.sortMode);
  if(cfg.mode==='qslCard'){ return grouped; }
  const skipSlots = Math.max(0, (cfg.startRow-1)*cfg.cols + (cfg.startCol-1));
  if(skipSlots===0) return grouped;
  const blanks = Array.from({length: skipSlots}, ()=> null);
  return blanks.concat(grouped);
}

/* ===== Recompute & PDF ===== */
function recompute(){
  const cfg=readConfig();
  const filtered = applyFilters(rows, cfg.f, cfg.dedupeMode);
  labels = buildLabelsWithOffset(filtered, cfg);
  const per=cfg.cols*cfg.rows; const pages=Math.max(1, Math.ceil(labels.length/per));
  currentPage = clamp(currentPage, 0, pages-1);
  computeStats(cfg, rows, filtered);
  if(!editorMode){ renderOnePage(cfg, currentPage); }
}
async function downloadPDF() {
    const cfg = readConfig();
    const filtered = applyFilters(rows, cfg.f, cfg.dedupeMode);
    const pdfLabels = buildLabelsWithOffset(filtered, cfg);
    if (filtered.length === 0) {
        alert("No QSOs match the current filters.");
        return;
    }
    const {
        jsPDF
    } = window.jspdf;
    const orientation = (cfg.pageWmm >= cfg.pageHmm) ? 'landscape' : 'portrait';
    const doc = new jsPDF({
        orientation,
        unit: "mm",
        format: [cfg.pageWmm, cfg.pageHmm],
        compress: true
    });
    const labelW_mm = (cfg.mode === 'qslCard') ? cfg.cardLabelWidthmm : computeGridLabelWidthMM(cfg);
    const labelH_mm = (cfg.mode === 'qslCard') ? cfg.cardLabelHeightmm : cfg.labelHmm;
    const labelWpt = mm2pt(labelW_mm);
    const labelHpt = mm2pt(labelH_mm);
    const per = cfg.cols * cfg.rows;
    const pages = Math.max(1, Math.ceil(pdfLabels.length / per));

    function pdfText(text, x_mm, y_mm, align = "left", font = "helvetica", style = "normal", size = 10, rotation = 0) {
        doc.setFont(font, style);
        doc.setFontSize(size);
        const opts = {
            align
        };
        if (rotation) {
            opts.angle = rotation;
        }
        doc.text(String(text ?? ""), x_mm, y_mm, opts);
    }

    function shrinkAndText(text, x_mm, y_mm, maxW_mm, font = "courier", style = "normal", startSize = 8.2, minSize = 5.0, step = 0.3, rotation = 0) {
        let sz = startSize;
        doc.setFont(font, style);
        doc.setFontSize(sz);
        while (doc.getTextWidth(String(text ?? "")) > maxW_mm && sz > minSize) {
            sz = Math.max(minSize, sz - step);
            doc.setFontSize(sz);
        }
        if (rotation) {
            doc.text(String(text ?? ""), x_mm, y_mm, {
                angle: rotation
            });
        } else {
            doc.text(String(text ?? ""), x_mm, y_mm);
        }
    }

    function drawRotatedRect(docInst, toPage, width_mm, height_mm) {
        const corners = [
            toPage(0, 0),
            toPage(width_mm, 0),
            toPage(width_mm, height_mm),
            toPage(0, height_mm)
        ];
        for (let i = 0; i < 4; i++) {
            const a = corners[i];
            const b = corners[(i + 1) % 4];
            docInst.line(a.x, a.y, b.x, b.y);
        }
    }
    const L = cfg.layout;
    const unlockCall = document.getElementById('unlockCallX');
    const callIsCentered = Boolean(L.callsign?.centerX) && !(unlockCall && unlockCall.checked);
    const callAlign = callIsCentered ? "center" : "left";
    const toRadioText = getToRadioLabel(cfg);
    doc.setFont("helvetica", "normal");
    doc.setFontSize(cfg.sizeToRadio);
    const toRadioWidthMmPdf = doc.getTextWidth(toRadioText);
    const callCenterLocalX_mm = computeCallCenterLocalXmm(cfg, L, labelW_mm, toRadioWidthMmPdf);
    for (let p = 0; p < pages; p++) {
        if (p > 0) doc.addPage([cfg.pageWmm, cfg.pageHmm], orientation);
        if (cfg.dbgOutline && cfg.mode === 'qslCard') {
            doc.setDrawColor(148);
            doc.setLineWidth(0.1);
            doc.rect(0, 0, cfg.pageWmm, cfg.pageHmm);
            doc.setDrawColor(0);
        }
        const start = p * per,
            end = Math.min(pdfLabels.length, start + per);
        for (let idx = start; idx < end; idx++) {
            const local = idx - start;
            const col = local % cfg.cols;
            const rowI = Math.floor(local / cfg.cols); // <-- THIS LINE IS THE FIX
            const item = pdfLabels[idx];
            const isBlank = !item || !item[0] && (!item[1] || item[1].length === 0);
            const {
                x0,
                y0
            } = computeLabelX0Y0(cfg, col, rowI, labelWpt, labelHpt);
            const x0_mm = pt2mm(x0);
            const y0_mm = pt2mm(y0);
            const rotation = (cfg.mode === 'qslCard') ? (cfg.cardLabelRotationDeg || 0) : 0;
            const rad = rotation * Math.PI / 180;
            const sinR = Math.sin(rad);
            const cosR = Math.cos(rad);
            const cx = x0_mm + labelW_mm / 2;
            const cy = y0_mm + labelH_mm / 2;
            const toPage = (lx_mm, ly_mm) => {
                const absX = x0_mm + lx_mm;
                const absY = y0_mm + ly_mm;
                if (!rotation) {
                    return {
                        x: absX,
                        y: absY
                    };
                }
                const dx = absX - cx;
                const dy = absY - cy;
                return {
                    x: cx + dx * cosR - dy * sinR,
                    y: cy + dx * sinR + dy * cosR
                };
            };
            const padX_mm = cfg.padXmm;
            if (cfg.dbgOutline) {
                doc.setDrawColor(187);
                doc.setLineWidth(0.1);
                if (rotation) {
                    drawRotatedRect(doc, toPage, labelW_mm, labelH_mm);
                } else {
                    doc.rect(x0_mm, y0_mm, labelW_mm, labelH_mm);
                }
                doc.setDrawColor(0);
            }
            if (isBlank) continue;
            const [call, chunk] = item;
            let colWpt;
            if (cfg.dynamicCols) {
                colWpt = computeColWidths(metricsCanvas.getContext('2d'), {
                    columns: cfg.columns,
                    sizeHeaders: cfg.sizeHeaders,
                    sizeRows: cfg.sizeRows,
                    fontBold: cfg.fontBold,
                    fontMono: cfg.fontMono,
                    minColMM: cfg.minColMM,
                    staticColMM: cfg.staticColMM,
                    colSlackPt: cfg.colSlackPt,
                    shrinkOnly: cfg.shrinkOnly,
                    padXmm: cfg.padXmm,
                    freqDecimals: cfg.freqDecimals,
                }, chunk, labelWpt);
            } else {
                const sum = cfg.staticColMM.reduce((a, b) => a + b, 0) || 1;
                const scale = labelWpt / mm2pt(sum);
                colWpt = cfg.staticColMM.map(mm => mm2pt(mm) * scale);
            }
            const toRadioPos = toPage(L.toRadio.x_mm, L.toRadio.y_mm);
            pdfText(toRadioText, toRadioPos.x, toRadioPos.y, "left", "helvetica", "normal", cfg.sizeToRadio, rotation);
            const callLocalX = callIsCentered ? callCenterLocalX_mm : (L.callsign.x_mm ?? padX_mm);
            const callPos = toPage(callLocalX, L.callsign.y_mm);
            const callSegments = buildCallSegments(call, chunk, cfg);
            drawCallSegmentsPdf(doc, callSegments, callPos.x, callPos.y, callAlign, rotation);
            let colAccumPt = 0;
            for (let i = 0; i < cfg.columns.length; i++) {
                const headerLocalX = pt2mm(colAccumPt) + padX_mm;
                const headerPos = toPage(headerLocalX, L.headers.y_mm);
                pdfText(cfg.columns[i].header, headerPos.x, headerPos.y, "left", "helvetica", "bold", cfg.sizeHeaders, rotation);
                colAccumPt += colWpt[i];
            }
            const lineGapPt = (L.table.lineGapPt ?? cfg.lineGapPt);
            for (let r = 0; r < cfg.rowsPerLabel; r++) {
                const data = chunk[r] || null;
                let colAccumPt2 = 0;
                for (let i = 0; i < cfg.columns.length; i++) {
                    const txt = data ? getCellText(data, cfg.columns[i].source, cfg) : "";
                    const localX = pt2mm(colAccumPt2) + padX_mm;
                    const localY = L.table.y_mm + pt2mm(lineGapPt * r);
                    const pos = toPage(localX, localY);
                    const maxW_mm = Math.max(0.1, pt2mm(colWpt[i]) - 2 * padX_mm);
                    shrinkAndText(txt, pos.x, pos.y, maxW_mm, "courier", "normal", cfg.sizeRows, 5.0, 0.3, rotation);
                    colAccumPt2 += colWpt[i];
                }
            }
            const footerLPos = toPage(L.footerL.x_mm, L.footerL.y_mm);
            pdfText(cfg.footerL, footerLPos.x, footerLPos.y, "left", "helvetica", "normal", cfg.sizeFooter, rotation);
            const footerRPos = toPage(L.footerR.x_mm, L.footerR.y_mm);
            pdfText(cfg.footerR, footerRPos.x, footerRPos.y, "right", "helvetica", "normal", cfg.sizeFooter, rotation);
        }
    }
    const baseName = cfg.mode === 'qslCard' ? 'qsl_card' : 'qsl_labels';
    const suffixMap = {
        PREFIX: '_by_prefix',
        DATE_ASC: '_by_date_old_to_new',
        DATE_DESC: '_by_date_new_to_old',
        FIFO: '_fifo'
    };
    const suffix = suffixMap[cfg.sortMode] || '';
    const fileName = `${baseName}${suffix||''}.pdf`;
    doc.save(fileName);
}

function downloadUpdatedAdif(){
    const cfg = readConfig();
    const exportScope = (cfg.exportScope || 'FILTERED').toUpperCase();
    const exportFilteredOnly = exportScope !== 'ALL';
    const filtered = applyFilters(rows, cfg.f, cfg.dedupeMode);
    if (!filtered.length && exportFilteredOnly) {
        alert("No QSOs match the current filters.");
        return;
    }
    const indexSet = new Set();
    filtered.forEach(row => {
        if (row && typeof row.__recIndex === 'number' && row.__recIndex >= 0) {
            indexSet.add(row.__recIndex);
        }
    });
    if (filtered.length && !indexSet.size) {
        alert("Unable to map filtered QSOs back to the original ADIF records.");
        return;
    }
    const recordSource = (Array.isArray(originalAdifRecords) && originalAdifRecords.length === recs.length)
        ? originalAdifRecords
        : recs.map(rec => serializeRecordFromObject(rec));
    const updatedRecords = [];
    for (let i = 0; i < recs.length; i++) {
        const base = recordSource[i] ?? serializeRecordFromObject(recs[i]);
        if (exportFilteredOnly && !indexSet.has(i)) {
            continue;
        }
        const recordBody = indexSet.has(i) ? ensureQslFields(base) : base;
        updatedRecords.push(recordBody.trim());
    }
    if (!updatedRecords.length) {
        alert("Nothing to export with the current settings.");
        return;
    }
    const headerLine = (originalAdifHeader && originalAdifHeader.trim().length)
        ? originalAdifHeader.trimEnd()
        : "Generated by QSL Labels v5.04";
    let output = "";
    if (headerLine) {
        output += headerLine + "\n";
    }
    output += "<EOH>\n";
    updatedRecords.forEach(body => {
        output += body + "\n<EOR>\n";
    });
    const name = adifDownloadName || "qsl_labels_updated.adi";
    downloadBlob(name, new Blob([output], { type: 'text/plain' }));
}

/* ===== Column UI & picker ===== */
function addColumnRow(header, source) {
    const wrap = document.getElementById('columns');
    const row = document.createElement('div');
    row.className = 'col-row';
    row.innerHTML = `<input class="col-h" type="text" placeholder="Header" value="${header||''}">
                 <select class="col-s"></select>
                 <button class="remove">✕</button>`;

    // FIX: Get references to the new inputs and attach the event listeners
    const headerInput = row.querySelector('.col-h');
    const sourceSelect = row.querySelector('.col-s');
    const recomputeDebounced = debounce(recompute, 120);
    headerInput.addEventListener('input', recomputeDebounced);
    sourceSelect.addEventListener('change', recomputeDebounced);

    const sel = sourceSelect;
    const defaults = ["DATE", "TIME", "BAND", "MODE", "QSL"];
    const seen = new Set();
    [...defaults, ...adifFields].forEach(tag => {
        if (!tag) return;
        const up = String(tag).toUpperCase();
        if (seen.has(up)) return;
        seen.add(up);
        const opt = document.createElement('option');
        opt.value = up;
        opt.textContent = up;
        sel.appendChild(opt);
    });
    if (source) {
        sel.value = String(source).toUpperCase();
    }
    row.querySelector('.remove').onclick = () => {
        row.remove();
        recompute();
    };
    wrap.appendChild(row);
} 
function resetDefaultColumns(){ const wrap=document.getElementById('columns'); wrap.innerHTML=""; [["Date","DATE"],["Time","TIME"],["Band","BAND"],["Mode","MODE"],["QSL","QSL"]].forEach(([h,s])=>addColumnRow(h,s)); }
function syncColArraysToDefaults(){ document.getElementById('minColMM').value="12,10,10,10,6"; document.getElementById('staticColMM').value="20,12,12,18,8"; }
function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }

/* ===== Sample data ===== */
function generateSampleRows(nLabels = 50, maxRowsPerLabel = 4) {
    const calls = [
        "9A3ST", "AA7PR", "CT1EAT", "DL1AAA", "EA7ZZ", "F5IN", "G0KSC", "HB9CVQ", "I2QSL", "JA1DX", "K3LR", "K4BAI",
        "K9CT", "LA2XPA", "LU5HAM", "LY4ZZ", "M0OXO", "N0AX", "OH2FIN", "ON4UN", "PA7LIM", "PY2KNK", "S50A", "SM5SRR",
        "SV3DCX", "TF3Y", "UA9BA", "VA3MW", "VK2CQ", "VU2NKS", "W1AW", "W3LPL", "W6NL", "XE2X", "YB0ANN", "YO9HP",
        "ZS6RAD", "ZS6Y", "ZR1ADI", "HB9CZF", "JA3USA", "OE3KAB", "OK2ZAW", "OM7KW", "OZ0J", "RA3CO", "SP7IDX", "SV1JG",
        "TA7OM", "UR5AS", "VE7CC", "VK9DX", "YU1XA", "ZL3IO"
    ];
    const modes = ["CW", "SSB", "FT8", "FT4", "RTTY", "PSK31", "JS8", "AM", "FM"];
    const bands = ["160M", "80M", "60M", "40M", "30M", "20M", "17M", "15M", "12M", "10M", "6M", "2M"];
    const today = new Date();
    const pad = n => String(n).padStart(2, "0");
    const records = [];
    const callCounts = new Map();
    const maxPerCall = 6;
    for (let i = 0; i < nLabels; i++) {
        const availableCalls = calls.filter(c => (callCounts.get(c) || 0) < maxPerCall);
        if (!availableCalls.length) {
            break;
        }
        const call = availableCalls[Math.floor(Math.random() * availableCalls.length)];
        const rCount = Math.max(1, Math.floor(Math.random() * maxRowsPerLabel) + 1);
        const remainingForCall = maxPerCall - (callCounts.get(call) || 0);
        const rowsForCall = Math.min(rCount, remainingForCall);
        for (let r = 0; r < rowsForCall; r++) {
            const randomDays = Math.floor(Math.random() * 730); // ~2 years span
            const d = new Date(today.getTime() - randomDays * 86400000);
            const date = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}`;
            const time = `${pad(Math.floor(Math.random() * 24))}${pad(Math.floor(Math.random() * 60))}`;
            records.push({
                CALL: call,
                QSO_DATE: date,
                TIME_ON: time,
                BAND: bands[Math.floor(Math.random() * bands.length)],
                MODE: modes[Math.floor(Math.random() * modes.length)],
                // The 'QSL' field will be derived automatically by buildRows
            });
            callCounts.set(call, (callCounts.get(call) || 0) + 1);
        }
    }
    return records;
}
function loadSample(){
  const maxRows=+(document.getElementById('rowsPerLabel').value)||4;
  recs = generateSampleRows(50, maxRows); // Store raw data in recs
  originalAdifHeader = "Generated by QSL Labels sample";
  originalAdifHasHeader = true;
  originalAdifRecords = recs.map(rec=>serializeRecordFromObject(rec));
  adifDownloadName = 'sample_qsl_updated.adi';
  rows = buildRows(recs); // Process it into rows
  const tags=new Set(); rows.forEach(r=>Object.keys(r).forEach(k=>tags.add(k.toUpperCase())));
  adifFields=Array.from(tags).sort();
  usingSample=true;
  document.querySelectorAll('.col-row .col-s').forEach(sel=>{
    const keep=sel.value; sel.innerHTML=""; const defaults=["DATE","TIME","BAND","MODE","QSL"]; const seen=new Set();
    [...defaults, ...adifFields].forEach(tag=>{ if(!tag) return; const up=String(tag).toUpperCase(); if(seen.has(up)) return; seen.add(up); const opt=document.createElement('option'); opt.value=up; opt.textContent=up; sel.appendChild(opt); });
    if(keep) sel.value=keep;
  });
  currentPage=0; recompute();
}

/* ===== Layout editor ===== */
let editorMode = false;
const layoutCanvas = document.getElementById('layoutEditor');
let dragging = null; 
const handleSizePt = 20; 
function toggleEditor(on){
  editorMode = on;
  document.getElementById('editorBar').style.display = on ? "flex" : "none";
  layoutCanvas.style.display = on ? "block" : "none";
  document.getElementById('preview').style.display = on ? "none" : "block";
  document.getElementById('previewControls').style.display = on ? "none" : "flex";
  if(on){ renderEditor(); } else { recompute(); }
}
function currentLabelDims(cfg){
  const labelW_mm=(cfg.mode==='qslCard') ? cfg.cardLabelWidthmm : computeGridLabelWidthMM(cfg);
  const labelH_mm=(cfg.mode==='qslCard') ? cfg.cardLabelHeightmm : cfg.labelHmm;
  return {labelW_mm,labelH_mm};
}
function renderEditor(){
  const cfg=readConfig();
  const {labelW_mm,labelH_mm}=currentLabelDims(cfg);
  const zoom=2;
  const ctx = setupHiDPICanvas(layoutCanvas, mm2pt(labelW_mm), mm2pt(labelH_mm), zoom);
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,mm2pt(labelW_mm),mm2pt(labelH_mm));
  ctx.strokeStyle="#bbb"; ctx.lineWidth=0.5; ctx.strokeRect(0,0,mm2pt(labelW_mm),mm2pt(labelH_mm));
  ctx.setLineDash([3,3]); ctx.strokeStyle="#d1d5db";
  ctx.strokeRect(mm2pt(cfg.padXmm), mm2pt(cfg.padYmm), mm2pt(labelW_mm-2*cfg.padXmm), mm2pt(labelH_mm-2*cfg.padYmm));
  ctx.setLineDash([]);
  const L=cfg.layout;
  const unlockCall = document.getElementById('unlockCallX');
  const callIsCentered = Boolean(L.callsign?.centerX) && !(unlockCall && unlockCall.checked);
  const callAlign = callIsCentered ? "center" : "left";
  const toRadioText = getToRadioLabel(cfg);
  const toRadioWidthMm = measureToRadioWidthMm(cfg);
  const callCenterLocalX_mm = computeCallCenterLocalXmm(cfg, L, labelW_mm, toRadioWidthMm);
  ctx.fillStyle="#000";
  ctx.font=`${cfg.sizeToRadio}px ${cfg.fontBody}`; ctx.textAlign="left";
  ctx.fillText(toRadioText, mm2pt(L.toRadio.x_mm), mm2pt(L.toRadio.y_mm));
  const callXpt = callIsCentered
    ? mm2pt(callCenterLocalX_mm)
    : (mm2pt(L.callsign.x_mm ?? cfg.padXmm));
  const sampleChunk = cfg.useQslVia ? [{ QSL_VIA: "SAMPLE" }] : [];
  drawCallSegmentsCanvas(ctx, buildCallSegments("SAMPLECALL", sampleChunk, cfg), callXpt, mm2pt(L.callsign.y_mm), callAlign);
  ctx.textAlign="left";
  ctx.font=`bold ${cfg.sizeHeaders}px ${cfg.fontBold}`;
  ctx.fillText("Date   Time   Band   Mode   QSL", mm2pt(cfg.padXmm), mm2pt(L.headers.y_mm));
  ctx.font=`${cfg.sizeRows}px ${cfg.fontMono}`;
  ctx.fillText("2025-09-09  12:34  20M   CW   TNX", mm2pt(cfg.padXmm), mm2pt(L.table.y_mm));
  ctx.font=`${cfg.sizeFooter}px ${cfg.fontBody}`;
  ctx.fillText(cfg.footerL || "Left footer", mm2pt(L.footerL.x_mm), mm2pt(L.footerL.y_mm));
  ctx.textAlign="right";
  ctx.fillText(cfg.footerR || "TNX & 73", mm2pt(L.footerR.x_mm), mm2pt(L.footerR.y_mm));
  ctx.textAlign="left";
  drawHandle(ctx, mm2pt(L.toRadio.x_mm), mm2pt(L.toRadio.y_mm), "toRadio");
  drawHandle(ctx, callXpt,              mm2pt(L.callsign.y_mm), "callsign", callIsCentered ? "y" : "xy");
  drawHandle(ctx, mm2pt(cfg.padXmm),    mm2pt(L.headers.y_mm), "headers", "y");
  drawHandle(ctx, mm2pt(cfg.padXmm),    mm2pt(L.table.y_mm),   "table",   "y");
  drawHandle(ctx, mm2pt(L.footerL.x_mm),mm2pt(L.footerL.y_mm), "footerL");
  drawHandle(ctx, mm2pt(L.footerR.x_mm),mm2pt(L.footerR.y_mm), "footerR");
  if(document.getElementById('showGuides').checked){
    ctx.fillStyle="#111827aa"; ctx.fillRect(6,6,160,64);
    ctx.fillStyle="#e5e7eb"; ctx.font="11px Arial";
    ctx.fillText("Drag the squares to move elements", 12, 22);
    ctx.fillText("Snap: hold Alt to disable", 12, 38);
    ctx.fillText("Callsign X locked unless unlocked", 12, 54);
  }
}
function drawHandle(ctx, xpt, ypt, key, lock="xy"){
  ctx.save();
  ctx.fillStyle="#38bdf8aa"; ctx.strokeStyle="#0284c7"; ctx.lineWidth=1;
  const hs=handleSizePt/2;
  ctx.fillRect(xpt-hs, ypt-hs, handleSizePt, handleSizePt);
  ctx.strokeRect(xpt-hs, ypt-hs, handleSizePt, handleSizePt);
  ctx.restore();
}
function hitTestHandle(cfg, xpt, ypt){
  const {labelW_mm} = currentLabelDims(cfg);
  const L=cfg.layout;
  const hs=handleSizePt/2;
  const unlockCall = document.getElementById('unlockCallX');
  const callIsCentered = Boolean(L.callsign?.centerX) && !(unlockCall && unlockCall.checked);
  const toRadioWidthMm = measureToRadioWidthMm(cfg);
  const callCenterLocalX_mm = computeCallCenterLocalXmm(cfg, L, labelW_mm, toRadioWidthMm);
  const callXpt = callIsCentered
    ? mm2pt(callCenterLocalX_mm)
    : (mm2pt(L.callsign.x_mm ?? cfg.padXmm));
  const handles = [
    {key:"toRadio", x:mm2pt(L.toRadio.x_mm), y:mm2pt(L.toRadio.y_mm), lock:"xy"},
    {key:"callsign",x:callXpt, y:mm2pt(L.callsign.y_mm), lock: callIsCentered?"y":"xy"},
    {key:"headers", x:mm2pt(cfg.padXmm), y:mm2pt(L.headers.y_mm), lock:"y"},
    {key:"table",   x:mm2pt(cfg.padXmm), y:mm2pt(L.table.y_mm), lock:"y"},
    {key:"footerL", x:mm2pt(L.footerL.x_mm), y:mm2pt(L.footerL.y_mm), lock:"xy"},
    {key:"footerR", x:mm2pt(L.footerR.x_mm), y:mm2pt(L.footerR.y_mm), lock:"xy"},
  ];
  for(const h of handles){
    if(xpt>=h.x-hs && xpt<=h.x+hs && ypt>=h.y-hs && ypt<=h.y+hs) return h;
  }
  return null;
}
layoutCanvas.addEventListener('pointerdown', (e)=>{
  if(!editorMode) return;
  const cfg=readConfig();
  const dpr=layoutCanvas.width / layoutCanvas.style.width.replace("px",""); 
  const x = e.offsetX / dpr, y = e.offsetY / dpr;
  const hit = hitTestHandle(cfg, x, y);
  if(hit){
    dragging = { key:hit.key, lock:hit.lock, dx:x-hit.x, dy:y-hit.y };
    layoutCanvas.setPointerCapture(e.pointerId);
  }
});
layoutCanvas.addEventListener('pointermove', (e)=>{
  if(!editorMode || !dragging) return;
  const cfg=readConfig();
  const dpr=layoutCanvas.width / layoutCanvas.style.width.replace("px",""); 
  const x = e.offsetX / dpr, y = e.offsetY / dpr;
  const {labelW_mm,labelH_mm}=currentLabelDims(cfg);
  const L=cfg.layout;
  const unlockCall = document.getElementById('unlockCallX');
  const callIsCentered = Boolean(L.callsign?.centerX) && !(unlockCall && unlockCall.checked);
  let nx = x - dragging.dx, ny = y - dragging.dy; 
  let x_mm = pt2mm(nx), y_mm = pt2mm(ny);
  const snap = parseFloat(document.getElementById('snapMM').value || "0.25");
  if(!e.altKey && snap>0){ x_mm = Math.round(x_mm/snap)*snap; y_mm = Math.round(y_mm/snap)*snap; }
  const xMin = cfg.padXmm, xMax = labelW_mm - cfg.padXmm;
  const yMin = cfg.padYmm, yMax = labelH_mm - cfg.padYmm;
  if(dragging.key==="toRadio"){
    if(dragging.lock!=="y") L.toRadio.x_mm = clamp(x_mm, xMin, xMax);
    if(dragging.lock!=="x") L.toRadio.y_mm = clamp(y_mm, yMin, yMax);
  }else if(dragging.key==="callsign"){
    if(callIsCentered){
      L.callsign.y_mm = clamp(y_mm, yMin, yMax);
    }else{
      L.callsign.x_mm = clamp(x_mm, xMin, xMax);
      L.callsign.y_mm = clamp(y_mm, yMin, yMax);
    }
  }else if(dragging.key==="headers"){
    L.headers.y_mm = clamp(y_mm, yMin, yMax);
  }else if(dragging.key==="table"){
    L.table.y_mm = clamp(y_mm, yMin, yMax);
  }else if(dragging.key==="footerL"){
    L.footerL.x_mm = clamp(x_mm, xMin, xMax);
    L.footerL.y_mm = clamp(y_mm, yMin, yMax);
  }else if(dragging.key==="footerR"){
    L.footerR.x_mm = clamp(x_mm, xMin, xMax);
    L.footerR.y_mm = clamp(y_mm, yMin, yMax);
  }
  L._custom = true;
  layoutState = L; 
  layoutStateByMode.set(cfg.mode || currentLayoutMode, layoutState);
  renderEditor();
});
layoutCanvas.addEventListener('pointerup', (e)=>{ dragging=null; layoutCanvas.releasePointerCapture?.(e.pointerId); });
layoutCanvas.addEventListener('pointercancel', ()=>{ dragging=null; });

/* ===== UI wiring & boot ===== */
function applyConfigToUI(cfg){
  const map={ pageSize:'pageSize', cols:'cols', rows:'rows', labelHmm:'labelH', marginLmm:'marginL', marginRmm:'marginR', colGapmm:'colGap', rowGapmm:'rowGap', marginTmm:'marginT',
    xOffmm:'xOffset', yOffmm:'yOffset', padXmm:'padX', padYmm:'padY', toRadioText:'toRadioText', footerL:'footerL', footerR:'footerR',
    footerRShiftmm:'footerRShift', footerYShiftmm:'footerYShift', rowsPerLabel:'rowsPerLabel', colSlackPt:'slackPt',
    lineGapPt:'lineGap', sizeToRadio:'sizeToRadio', sizeCallsign:'sizeCallsign', sizeViaLabel:'sizeViaLabel', sizeViaManager:'sizeViaManager',
    sizeHeaders:'sizeHeaders', sizeRows:'sizeRows', sizeFooter:'sizeFooter',
    startRow:'startRow', startCol:'startCol', sortMode:'sortMode'
  };
  if(cfg.sortMode){
    const normalizedSort = String(cfg.sortMode).toUpperCase();
    cfg.sortMode = SORT_MODES.includes(normalizedSort) ? normalizedSort : 'CALL';
  }else{
    cfg.sortMode = 'CALL';
  }
  if(cfg.dedupeMode){
    const normalizedDedupe = String(cfg.dedupeMode).toUpperCase();
    cfg.dedupeMode = (normalizedDedupe==='NEWEST' || normalizedDedupe==='OLDEST') ? normalizedDedupe : 'OFF';
  }else{
    cfg.dedupeMode = 'OFF';
  }
  const gapVal = Number(cfg.colGapmm);
  cfg.colGapmm = Number.isFinite(gapVal) ? Math.max(0, gapVal) : 0;
  const rowGapVal = Number(cfg.rowGapmm);
  cfg.rowGapmm = Number.isFinite(rowGapVal) ? Math.max(0, rowGapVal) : 0;
  for(const k in map){ if(cfg[k]!==undefined) document.getElementById(map[k]).value=cfg[k]; }
  if(cfg.fontBody) document.getElementById('fontBody').value=cfg.fontBody;
  if(cfg.fontMono) document.getElementById('fontMono').value=cfg.fontMono;
  if(cfg.fontBold) document.getElementById('fontBold').value=cfg.fontBold;
  if(cfg.dateFormat) document.getElementById('dateFormat').value=cfg.dateFormat;
  if(cfg.freqDecimals!==undefined){
    const val = Number(cfg.freqDecimals);
    const safe = Number.isFinite(val) ? clamp(Math.round(val), 0, 6) : 3;
    document.getElementById('freqDecimals').value = safe;
  }
  if(cfg.colOffsets) document.getElementById('colOffsets').value = cfg.colOffsets.join(",");
  if(cfg.rowOffsets) document.getElementById('rowOffsets').value = cfg.rowOffsets.join(",");
  if(cfg.minColMM) document.getElementById('minColMM').value = cfg.minColMM.join(",");
  if(cfg.staticColMM) document.getElementById('staticColMM').value = cfg.staticColMM.join(",");
  if(cfg.exportScope){
    const normalizedScope = String(cfg.exportScope).toUpperCase();
    document.getElementById('exportScope').value = normalizedScope === 'ALL' ? 'ALL' : 'FILTERED';
  }
  if(cfg.themeName){ applyTheme(cfg.themeName, false); }
  else if(currentThemeName){ applyTheme(currentThemeName, false); }
  document.querySelectorAll('.mode-option').forEach(btn=>{
    btn.classList.toggle('selected', btn.dataset.mode === (cfg.mode==='qslCard'?'qslCard':'labels'));
  });
  if(cfg.cardWidthmm!==undefined) document.getElementById('cardWidth').value = cfg.cardWidthmm;
  if(cfg.cardHeightmm!==undefined) document.getElementById('cardHeight').value = cfg.cardHeightmm;
  if(cfg.cardLabelWidthmm!==undefined) document.getElementById('cardLabelWidth').value = cfg.cardLabelWidthmm;
  if(cfg.cardLabelHeightmm!==undefined) document.getElementById('cardLabelHeight').value = cfg.cardLabelHeightmm;
  if(cfg.cardLabelXmm!==undefined) document.getElementById('cardLabelX').value = cfg.cardLabelXmm;
  if(cfg.cardLabelYmm!==undefined) document.getElementById('cardLabelY').value = cfg.cardLabelYmm;
  if(cfg.cardLabelRotationDeg!==undefined) document.getElementById('cardLabelRotation').value = cfg.cardLabelRotationDeg;
  const useViaEl=document.getElementById('useQslVia');
  if(useViaEl){ useViaEl.value = cfg.useQslVia ? "1" : "0"; }
  updateModeVisibility();
}
function initCollapsibles(){
  document.querySelectorAll('.collapsible').forEach(section=>{
    const toggle=section.querySelector('.section-toggle');
    const body=section.querySelector('.section-body');
    if(!toggle || !body) return;
    if(section.dataset.collapsibleBound) return;
    let collapsed = section.dataset.initial === 'collapsed' || body.classList.contains('collapsed');
    section.classList.toggle('is-collapsed', collapsed);
    body.classList.toggle('collapsed', collapsed);
    toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    toggle.addEventListener('click', ()=>{
      const isCollapsed = section.classList.toggle('is-collapsed');
      toggle.setAttribute('aria-expanded', isCollapsed ? 'false' : 'true');
      body.classList.toggle('collapsed', isCollapsed);
    });
    section.dataset.collapsibleBound = '1';
  });
}
function updateModeVisibility(){
  const modeSelBtn=document.querySelector('.mode-option.selected');
  const mode = modeSelBtn ? modeSelBtn.dataset.mode : 'labels';
  document.body.classList.toggle('card-mode', mode==='qslCard');
  const pageSizeEl=document.getElementById('pageSize');
  if(pageSizeEl){ pageSizeEl.disabled = (mode==='qslCard'); }
}
function autoResizeOffsetCSVs(){
  const cols=+(document.getElementById('cols').value||3);
  const rowsCount=+(document.getElementById('rows').value||8);
  function fitCsv(id,len){ const arr=parseCSVfloats(document.getElementById(id).value); if(arr.length<len) arr.push(...Array(len-arr.length).fill(0)); if(arr.length>len) arr.length=len; document.getElementById(id).value = arr.join(','); }
  fitCsv('colOffsets', cols); fitCsv('rowOffsets', rowsCount);
}
function bindInputs(){
  document.querySelectorAll('input,select,button').forEach(el=>{
    if(["adifFile","downloadBtn","downloadAdifBtn","saveCfg","loadCfg","addCol","resetCols","prevPage","nextPage","pickOk","pickCancel","reloadSample","editLayoutBtn","resetLayout","applyLayout","closeEditor","dateFormat","addQslRule"].includes(el.id)) return;
    if(el.id==='themeSelect') return;
    if(el.classList.contains('section-toggle') || el.classList.contains('mode-option')) return;
    el.addEventListener('input', debounce(()=>{ if(el.id==="cols"||el.id==="rows") autoResizeOffsetCSVs(); recompute(); },120));
    el.addEventListener('change', debounce(()=>{ if(el.id==="cols"||el.id==="rows") autoResizeOffsetCSVs(); recompute(); },120));
  });
  const themeSelect=document.getElementById('themeSelect');
  if(themeSelect){ themeSelect.addEventListener('change', ()=>{ applyTheme(themeSelect.value); }); }
  document.querySelectorAll('.mode-option').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('.mode-option').forEach(b=>b.classList.remove('selected'));
      btn.classList.add('selected');
      updateModeVisibility();
      recompute();
    });
  });
  document.getElementById('dateFormat').addEventListener('change', () => {
    rows = buildRows(recs);
    recompute();
  });
  document.getElementById('zoom').addEventListener('input', recompute);
  document.getElementById('addCol').onclick=()=> openPicker();
  document.getElementById('resetCols').onclick=()=>{ resetDefaultColumns(); syncColArraysToDefaults(); recompute(); };
  document.getElementById('pickCancel').onclick=()=> closePicker();
  document.getElementById('pickOk').onclick=()=>{ const h=document.getElementById('pickHeader').value||"Header"; const s=document.getElementById('pickSource').value||"DATE"; addColumnRow(h,s); closePicker(); recompute(); };
  document.getElementById('prevPage').onclick=()=>{ const cfg=readConfig(); const per=cfg.cols*cfg.rows; const pages=Math.max(1,Math.ceil((labels?.length||0)/per)); currentPage=Math.max(0,currentPage-1); document.getElementById('pageInfo').textContent=`Page ${currentPage+1} / ${pages}`; renderOnePage(cfg, currentPage); };
  document.getElementById('nextPage').onclick=()=>{ const cfg=readConfig(); const per=cfg.cols*cfg.rows; const pages=Math.max(1,Math.ceil((labels?.length||0)/per)); currentPage=Math.min(pages-1,currentPage+1); document.getElementById('pageInfo').textContent=`Page ${currentPage+1} / ${pages}`; renderOnePage(cfg, currentPage); };
  document.getElementById('adifFile').addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if(!f) return; const txt=await f.text();
    const normalized = txt.replace(/\r\n?/g,"\n");
    const eohMatch = normalized.match(/<eoh>/i);
    let header = "";
    let body = normalized;
    if(eohMatch){
      header = normalized.slice(0, eohMatch.index);
      body = normalized.slice(eohMatch.index + eohMatch[0].length);
      originalAdifHasHeader = true;
    }else{
      header = "";
      body = normalized;
      originalAdifHasHeader = false;
    }
    const rawChunks = body.split(/<eor>/ig);
    const recordStrings = [];
    rawChunks.forEach(chunk=>{
      const trimmed = chunk.trim();
      if(trimmed) recordStrings.push(trimmed);
    });
    const recsRaw=parseADIF(normalized); recs=recsRaw; rows=buildRows(recs);
    originalAdifHeader = header.replace(/\s+$/,'');
    originalAdifRecords = recordStrings.length === recsRaw.length ? recordStrings : recsRaw.map(rec=>serializeRecordFromObject(rec));
    if(originalAdifRecords.length !== recsRaw.length){
      originalAdifRecords = recsRaw.map(rec=>serializeRecordFromObject(rec));
    }
    const stem = f.name ? f.name.replace(/\.(adi|adif|txt)$/i, '') : 'adif';
    adifDownloadName = `${stem || 'adif'}_qsl_updated.adi`;
    const tags=new Set(); recs.forEach(r=>Object.keys(r).forEach(k=>tags.add(k.toUpperCase())));
    adifFields=Array.from(tags).sort();
    usingSample=false; currentPage=0;
    document.querySelectorAll('.col-row .col-s').forEach(sel=>{
      const keep=sel.value; sel.innerHTML=""; const defaults=["DATE","TIME","BAND","MODE","QSL"]; const seen=new Set();
      [...defaults, ...adifFields].forEach(tag=>{ if(!tag) return; const up=String(tag).toUpperCase(); if(seen.has(up)) return; seen.add(up); const opt=document.createElement('option'); opt.value=up; opt.textContent=up; sel.appendChild(opt); });
      if(keep) sel.value=keep;
    });
    recompute();
    try {
      const uniqueCalls = new Set((rows||[]).map(r=>r.CALL)).size;
      gtag('event', 'adif_upload', {
        file_name: f.name,
        file_ext: (f.name.split('.').pop()||'').toLowerCase(),
        file_size_bytes: f.size || 0,
        qso_rows: rows?.length || 0,
        unique_calls: uniqueCalls,
        sample_data_used: usingSample ? 'yes' : 'no'
      });
    } catch(e){ /* no-op */ }
  });
  document.getElementById('downloadBtn').onclick=downloadPDF;
  const dlAdifButton = document.getElementById('downloadAdifBtn');
  if(dlAdifButton){ dlAdifButton.onclick=downloadUpdatedAdif; }
  const adifTooltip = document.querySelector('.download-tooltip');
  if(adifTooltip){
    let tooltipTimer;
    const showTooltip = () => {
      clearTimeout(tooltipTimer);
      adifTooltip.classList.add('is-active');
      tooltipTimer = window.setTimeout(()=>{ adifTooltip.classList.remove('is-active'); }, 3000);
    };
    const hideTooltip = () => {
      clearTimeout(tooltipTimer);
      adifTooltip.classList.remove('is-active');
    };
    adifTooltip.addEventListener('mouseenter', showTooltip);
    adifTooltip.addEventListener('mouseleave', hideTooltip);
    adifTooltip.addEventListener('focusin', showTooltip);
    adifTooltip.addEventListener('focusout', hideTooltip);
  }
  document.getElementById('saveCfg').onclick=()=>{
    const cfg=configWithoutFilters(readConfig());
    downloadBlob('qsl_config.json', new Blob([JSON.stringify(cfg,null,2)],{type:'application/json'}));
  };
  document.getElementById('loadCfg').addEventListener('change', async e => {
    const f = e.target.files?.[0]; // CORRECTED THIS LINE
    if (!f) return;
    const txt = await f.text();
    try {
        const obj = JSON.parse(txt);

        // Restore columns from the loaded configuration file
        if (obj.columns && Array.isArray(obj.columns)) {
            const wrap = document.getElementById('columns');
            wrap.innerHTML = ""; // Clear existing columns before adding new ones
            obj.columns.forEach(col => addColumnRow(col.header, col.source));
        }

        if (layoutState) {
            layoutStateByMode.set(currentLayoutMode, layoutState);
        }
        const sanitized = configWithoutFilters(obj);
        applyConfigToUI(sanitized);
        if (obj.layout) {
            layoutState = obj.layout;
            layoutState._custom = obj.layout._custom ?? true;
            const targetMode = (obj.mode && obj.mode.toLowerCase() === 'qslcard') ? 'qslCard' : (obj.mode || currentLayoutMode);
            currentLayoutMode = targetMode;
            layoutStateByMode.set(currentLayoutMode, layoutState);
        }
        autoResizeOffsetCSVs();
        rows = buildRows(recs); // Re-process data after loading config with new date format
        recompute();
    } catch {
        alert("Invalid config JSON");
    }
});
  document.getElementById('reloadSample').onclick=()=> loadSample();
  const editBtn=document.getElementById('editLayoutBtn');
  if(editBtn) editBtn.onclick=()=> toggleEditor(true);
  document.getElementById('resetLayout').onclick=()=>{ const cfg=readConfig(); layoutState = defaultLayout(cfg); layoutState._custom = false; layoutStateByMode.set(cfg.mode||currentLayoutMode, layoutState); renderEditor(); };
  document.getElementById('applyLayout').onclick=()=>{ toggleEditor(false); };
  document.getElementById('closeEditor').onclick=()=> toggleEditor(false);
  updateModeVisibility();
}

/* ===== Column picker overlay ===== */
const picker=document.getElementById('picker');
function openPicker(){
  const select=document.getElementById('pickSource'); select.innerHTML="";
  const defaults=["DATE","TIME","BAND","MODE","QSL"]; const seen=new Set();
  [...defaults, ...adifFields].forEach(tag=>{ if(!tag) return; const up=String(tag).toUpperCase(); if(seen.has(up)) return; seen.add(up); const opt=document.createElement('option'); opt.value=up; opt.textContent=up; select.appendChild(opt); });
  document.getElementById('pickHeader').value="Header"; picker.style.display="flex";
}
function closePicker(){ picker.style.display="none"; }

/* ===== Boot ===== */
resetDefaultColumns();
syncColArraysToDefaults();
initTheme();
initCollapsibles();
initQslRuleBuilder();
bindInputs();
loadSample();
</script>
</body>
</html>
